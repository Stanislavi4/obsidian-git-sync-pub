Содержание

1. 1. [Как открыть PowerShell в Windows](https://blog.skillfactory.ru/glossary/powershell/#как-открыть-powershell-в-windows)
2. 2. [Команды (командлеты) PowerShell](https://blog.skillfactory.ru/glossary/powershell/#команды-командлеты-powershell)
3. 3. [Объекты и конвейеры (пайплайны) в PowerShell](https://blog.skillfactory.ru/glossary/powershell/#объекты-и-конвейеры-пайплайны-в-powershell)
4. 4. [Фоновое выполнение команд](https://blog.skillfactory.ru/glossary/powershell/#фоновое-выполнение-команд)
5. 5. [Работа с файлами](https://blog.skillfactory.ru/glossary/powershell/#работа-с-файлами)
6. 6. [Работа в PowerShell ISE](https://blog.skillfactory.ru/glossary/powershell/#работа-в-powershell-ise)
7. 7. [Переменные](https://blog.skillfactory.ru/glossary/powershell/#переменные)
8. 8. [Логические операторы](https://blog.skillfactory.ru/glossary/powershell/#логические-операторы)
9. 9. [Работа со строками в PowerShell](https://blog.skillfactory.ru/glossary/powershell/#работа-со-строками-в-powershell)
10. 10. [Условия](https://blog.skillfactory.ru/glossary/powershell/#условия)
11. 11. [Циклы](https://blog.skillfactory.ru/glossary/powershell/#циклы)
12. 12. [Массивы, хеш-таблицы, функции и классы](https://blog.skillfactory.ru/glossary/powershell/#массивы-хештаблицы-функции-и-классы)
13. 13. [Для чего нужен PowerShell](https://blog.skillfactory.ru/glossary/powershell/#для-чего-нужен-powershell)
14. 14. [Чем PowerShell отличается от cmd](https://blog.skillfactory.ru/glossary/powershell/#чем-powershell-отличается-от-cmd)
15. 15. [Итоги](https://blog.skillfactory.ru/glossary/powershell/#итоги)

**Windows PowerShell** — программа, который объединяет в себе командную оболочку и среду для написания сценариев. Она базируется на [.NET](https://blog.skillfactory.ru/glossary/net/) и предоставляет средства для управления компьютером и автоматизации рутинных задач. Платформа обладает функциональностью полноценного [объектно-ориентированного языка](https://blog.skillfactory.ru/glossary/oop-obektno-orientirovannoe-programmirovanie/), включая поддержку [переменных](https://blog.skillfactory.ru/glossary/peremennaya/), функций, классов и объектов.

В отличие от многих других командных оболочек, PowerShell при работе оперирует не строками, а **объектами**. Это позволяет разрабатывать и применять сложные логические конструкции. Важно отметить, что [интерпретатор](https://blog.skillfactory.ru/glossary/interpretator/) PowerShell полностью совместим со стандартными командами cmd.exe и способен выполнять их функции без ограничений.

Взаимодействие с командами осуществляется в интерактивном режиме внутри терминала. Однако, если требуется сохранить используемый [скрипт](https://blog.skillfactory.ru/glossary/skript/), более удобным вариантом станет использование среды ISE.

**Windows PowerShell ISE** представляет собой интегрированное средство разработки сценариев для языка PowerShell. Здесь можно создавать, сохранять и запускать скрипты с выделением [синтаксиса](https://blog.skillfactory.ru/glossary/sintaksis/), автоматическим дополнением, справочником команд и инструментами [отладки](https://blog.skillfactory.ru/glossary/otladka-debugging/). PowerShell ISE является легаси-инструментом, специфичным для версий языка до 5.1 включительно. В более поздних версиях предпочтение отдается универсальным интегрированным средам разработки с плагинами.

С начала 2016 года язык получил **кросс-платформенную** поддержку. Теперь его можно применять не только в операционных системах Windows 7, 8, 10, и 11, но и на macOS (начиная с версии 10.13), а также на различных популярных дистрибутивах [Linux](https://blog.skillfactory.ru/glossary/linux/) (подробная информация о совместимых дистрибутивах доступна в [официальной документации](https://learn.microsoft.com/ru-ru/powershell/scripting/install/installing-powershell-on-linux?view=powershell-7.3)).

## Как открыть PowerShell в Windows

Как правило, PowerShell уже установлен на вашем компьютере по умолчанию. Однако, если по какой-то причине его нет, вы можете воспользоваться инструкциями, предоставленными Microsoft. В дополнение, в официальной документации имеются подробные руководства по установке на macOS и Linux.

PowerShell является независимым от версии [операционной системы](https://blog.skillfactory.ru/glossary/operaczionnaya-sistema/) инструментом и работает одинаково стабильно как на Windows 10, так и на Windows Server.

Существует два основных метода для запуска PowerShell или PowerShell ISE в системе Windows: через меню «**Пуск**» и с помощью приложения «**Выполнить**».

- Для того чтобы открыть PowerShell **через меню «Пуск»**, пройдите к папке Windows PowerShell, откройте её и выберите необходимое приложение. В этой директории доступны как 32-разрядные версии (отмечены как x86 в скобках), так и 64-разрядные версии терминала и ISE.

![открыть PowerShell можно через Пуск](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-otkritie.jpg)

- Чтобы запустить PowerShell **через приложение «Выполнить»**, используйте комбинацию клавиш **Win + R**. Когда появится окно, введите `powershell` или `powershell ise` (в зависимости от того, какое приложение вам нужно) и нажмите кнопку **ОК**.

![открытие PowerShell через команду выполнить](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-otkritie-vipolnit.jpg)

## Команды (командлеты) PowerShell

В языке программы PowerShell команды носят название **командлеты** (от английского «cmdlet»). Все они формируются с использованием шаблона «Глагол-Существительное», или «Действие-Объект». Например,

Get-Services

и

Start-Process

. Благодаря такой структуре, можно легко понять предназначение команды, даже если вы с ней ещё не работали ранее.

### Синтаксис командлетов

После имени самого командлета следует указание параметров и их значений. Между всеми частями команды следует проставлять пробелы. Вот пример синтаксиса командлета, который позволяет перейти в директорию `**C:\**`:

Set-Location -LiteralPath C:\ -PassThru

Разберем его на составные части:

- Set-Location
    
    — буквально «вызвать команду». Этот командлет позволяет выполнять указанный блок сценария.
- -LiteralPath C:\
    
    — здесь передаем блок сценария, в котором используется команда
    
    Set-Location
    
    для перехода в каталог `**C:\**`.
- -PassThru
    
    — по умолчанию командлет
    
    Invoke-Command
    
    не возвращает результат выполнения. Этот параметр указывает на необходимость вывода информации о местоположении, в которое был выполнен переход с помощью команды
    
    Set-Location
    
    .

![переход в директорию C в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-komandi-1024x346.jpg)

==**Важно отметить, что регистр букв в командах PowerShell не имеет значения.**== Таким образом, данную команду можно записать в виде заглавных букв, строчных букв или даже смешанного регистра, и она все равно будет выполняться:

sEt-loCATion -PATH c:\ -passthru

Когда в одной строке объединены несколько команд, они разделяются точкой с запятой

`;`

.

Иногда команда может быть слишком длинной. Для разделения на несколько строк можно использовать символ обратного апострофа

`

в месте переноса. Новую строку можно создать, нажав **Shift + Enter** (для переноса строки ниже текущей) или **Ctrl + Enter** (для переноса строки выше текущей).

Разделим предыдущую команду:

Set-Location `

-LiteralPath C:\ `

-PassThru

![разделение длинной команды в powershell обратным апострофом для переноса на новую строку](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-komandi-2.jpg)

#### **ПОЛЕЗНЫЙ СОВЕТ**  
  
Использование стрелок вверх и вниз позволяет просматривать историю введенных вами команд. Это может быть очень удобным, если вам необходимо повторно выполнить одну из предыдущих команд или внести небольшие корректировки в уже введенное.

### Алиасы

В процессе работы с терминалом иногда может быть неудобно постоянно вводить полные названия командлетов. Именно поэтому у наиболее часто используемых командлетов существуют псевдонимы (алиасы) — их сокращенные варианты.

Чтобы получить список доступных алиасов, вы можете воспользоваться командой

Get-Alias

. Кроме того, данной команде также доступен псевдоним

gal

.

![список доступных алиасов в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-get-alias-1024x444.jpg)

Чтобы получить список алиасов для конкретного командлета, вы можете использовать параметр

-Definition

. Пример:

Get-Alias -Definition Set-Location

![список алиасов командлета set-location в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-definition-1024x253.jpg)

Если вам нужно узнать полное название командлета по его алиасу, используйте параметр

-Name

. Этот параметр необязателен, так как он является аргументом по умолчанию.

# Оба следующих варианта эквивалентны:

Get-Alias -Name clear

Get-Alias clear

![работа параметра -Name в PowerShell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-name-1024x367.jpg)

### Особенности обработки путей к каталогам

Для многих командлетов необходимо предоставить путь к файлу или каталогу. Это делается с использованием строки, например:

C:\Windows\System32

.

Однако, если в пути встречается пробел или другой специальный символ, PowerShell будет рассматривать его как разделитель. Например:

# Следующая команда не будет выполнена корректно

Set-Location C:\Program Files

![пример некорректной команды в powershell: не удается найти позиционный параметр](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-set-location-1024x205.jpg)

PowerShell «воспринимает» пробел и интерпретирует его так, будто путь к папке закончился на слове

Program

, а

files

— это уже значение другого параметра.

Чтобы избежать подобных ситуаций, существует два метода:

- Экранировать символы с помощью обратного апострофа
    
    `
    
    :
    
    C:\Program` Files
    
    . Однако это может быть неудобным, если путь длинный.
- Поместить весь путь в одинарные или двойные кавычки:
    
    'C:\Program Files'
    
    или
    
    "C:\Program Files"
    
    (желательнее использовать одинарные кавычки).

Кроме того, в PowerShell существуют сокращения для быстрого доступа к ближайшим директориям:

- Точка
    
    .
    
    указывает на текущий каталог. Например,
    
    Get-ChildItem .
    
    позволяет просмотреть содержимое текущего местоположения.
- Две точки
    
    ..
    
    указывают на родительский каталог. Например,
    
    Set-Location ..
    
    позволяет перейти к родительскому каталогу. Это может быть полезно, если вы находитесь в глубоко вложенной директории.

Большинство командлетов имеют параметры

-Path

и

-LiteralPath

, позволяющие указать путь к файлу или папке. Разница между ними заключается в том, что в

-Path

можно включать переменные, в то время как —

LiteralPath

интерпретирует символы буквально, даже если они содержат имя переменной.

### Get-Help: как изучать новые командлеты

Для получения подробной информации о конкретном командлете воспользуйтесь командой

Get-Help Название-Командлета

. Пример:

Get-Help Get-Childitem

![Get-Help получить информацию о командлете get-childitem в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-get-help-1024x447.jpg)

У команды

Get-Help

имеется несколько полезных параметров:

- -Detailed
    
    предоставляет более подробную справку по командлету.
- -Full
    
    предоставляет полную справку.
- -Examples
    
    демонстрирует примеры использования командлета.
- -Online
    
    перенаправляет пользователя на веб-страницу с соответствующей документацией.

## Объекты и конвейеры (пайплайны) в PowerShell

Когда вы работаете с командлетами в PowerShell, они возвращают не просто строки, а [объекты](https://blog.skillfactory.ru/glossary/oop-obektno-orientirovannoe-programmirovanie/) — структуры данных, содержащие набор свойств и методов. 

То, что отображается в терминале после выполнения команды в виде строки, на самом деле является визуальным представлением объекта. Программа PowerShell отображает определенные свойства объектов в виде таблицы, но далеко не все свойства могут быть отображены таким образом.

Аналогично тому, как командлеты могут возвращать объекты, они также могут принимать и обрабатывать их. Вы можете создать команду, которая возвращает объект, передать этот объект другому командлету, получить объект из него и так далее — этот процесс и называется **конвейерами** или **пайплайнами**.

Чтобы передать результат одного командлета другому, используется символ вертикальной черты

|

.

### Пример работы конвейера в PowerShell

Команда

Get-Process

возвращает список запущенных процессов на компьютере. При передаче ей имени процесса (или шаблона, созданного с помощью регулярных выражений), команда выведет только соответствующие элементы списка.

Рассмотрим пример, где вызываем запущенный процесс

PowerShell

:

Get-Process powershell

![вызов процесса powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-get-process.jpg)

Мы получаем объект и таблицу, отображающую некоторые его свойства. Чтобы узнать все свойства и методы, давайте передадим этот объект командлету

Get-Member

. Для этого используется конвейер:

Get-Process powershell | Get-Member

![get process и get member конвейер в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-member-1024x657.jpg)

Команда

Get-Member

получает объект от команды

Get-Process

и выводит таблицу со всеми его свойствами и методами. Результат работы

Get-Member

также представляет собой объект (точнее, список объектов), который можно передать по конвейеру дальше.

Допустим, нужно вывести только те строки, в которых

MemberType

равно

Property

. Для этого используем команду

Where-Object

:

Get-Process powershell | Get-Member | Where-Object {$_.MemberType -eq 'Property'}

![пример работы команды Where-Object в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-property-1024x748.jpg)

Команда

Where-Object

последовательно обходит каждый объект, полученный от команды

Get-Member

. Выражение в фигурных скобках — логическое:

- $_
    
    ссылается на текущий объект (то есть на отдельную строку в таблице);
- .MemberType
    
    обращается к значению свойства
    
    MemberType
    
    в этом объекте;
- -eq
    
    выполняет сравнение между выражением слева и выражением справа от него;
- 'Property'
    
    представляет значение, которое ожидаем увидеть у свойства
    
    MemberType
    
    .

Более подробно о логических выражениях рассказано ниже.

### Форматирование таблиц с помощью конвейеров

Командлет

Format-Table

в PowerShell предоставляет возможность настроить вывод таблицы в терминале: выбирать нужные свойства и методы, устанавливать ширину столбцов, группировать данные по нескольким таблицам и т. д.

Форматируем таблицу, полученную с помощью командлета

Get-Member

. Следует использовать следующий синтаксис:

Get-Process powershell | Get-Member | Format-Table -AutoSize -Wrap -GroupBy MemberType -Property Name, Definition

![format table в powershell - форматирование таблицы](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-komanda-1024x550.jpg)

Разберем параметры командлета

Format-Table

:

- -AutoSize
    
    выравнивает ширину столбцов в соответствии с размерами их содержимого. Это позволяет оптимально использовать ширину экрана.
- -Wrap
    
    переносит содержимое ячейки на новую строку, если оно не помещается в текущих размерах экрана. По умолчанию, если текст не помещается, он обрезается.
- -GroupBy
    
    позволяет разделить одну таблицу на несколько, сгруппированных по значению определенного свойства. В данном случае, для каждого значения
    
    MemberType
    
    будет создана отдельная таблица.
- -Property
    
    определяет, какие свойства объекта будут отображены в таблице в качестве столбцов. В данном примере, мы указали свойства
    
    Name
    
    и
    
    Definition
    
    .

Эти параметры позволяют настраивать внешний вид таблицы, сделать вывод более читабельным и структурированным.

### Сортировка таблиц с помощью конвейеров

Командлет

Sort-Object

в PowerShell позволяет сортировать список объектов (таблицу) по значениям их свойств (столбцов). Давайте отсортируем результат, полученный с помощью командлета

Get-Member

, по столбцу

Name

в алфавитном порядке. Для этого  воспользуемся параметром

-Property

, который действует аналогично параметру у командлета

Format-Table

:

Get-Process powershell | Get-Member | Sort-Object -Property Name

![сортировка таблиц sort-object в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-sort-object-1024x530.jpg)

Командлет Sort-Object в PowerShell имеет также другие полезные параметры:

- -Descending
    
    сортирует объекты в порядке убывания. Например:

Get-Process powershell | Get-Member | Sort-Object -Property Name -Descending

- -Unique
    
    удаляет дубликаты и возвращает только уникальные объекты. Например:

Get-Process powershell | Get-Member | Sort-Object -Property Name -Unique

- Параметр
    
    -Top
    
    получает число N и отображает первые N объектов в таблице. Например:

Get-Process | Sort-Object -Property CPU -Top 10

- Параметр
    
    -Bottom
    
    получает число N и отображает последние N объектов в таблице. Например:

Get-Process | Sort-Object -Property Memory -Descending -Bottom 5

Эти параметры позволяют более гибко настраивать сортировку и отображение объектов в выводе.

## Фоновое выполнение команд

Определенные задачи могут требовать значительного времени на выполнение. Примеры таких задач включают установку и обновление программного обеспечения или поиск файлов в обширной директории. ==**Важно помнить, что во время выполнения одной команды в PowerShell нельзя вводить другие команды.**==

Рассмотрим пример: предположим, нужно найти файл

powershell.exe

на всем диске **C**. Для этой цели  воспользуемся командлетом

Get-ChildItem

с параметром

-Recurse

. Это позволит ему искать файл не только в текущем каталоге, но и во всех его подкаталогах.

Следует учитывать, что PowerShell может столкнуться с папками, к которым у него нет доступа. Чтобы обойти возможные ошибки, добавим параметр

-ErrorAction SilentlyContinue

. Это означает, что в случае ошибки команда не будет генерировать уведомления, а просто продолжит выполнение.

Таким образом, данная ситуация выглядит следующим образом:

Get-ChildItem -Path C:\ -Name powershell.exe -Recurse -ErrorAction SilentlyContinue

![поиск файла в powershell с помощью get childitem recurse](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-primer-1024x85.jpg)

Очевидно, что во время выполнения задачи, командная строка становится недоступной. Для принудительного прерывания выполнения задачи можно воспользоваться сочетанием клавиш **Ctrl + C**. Важно убедиться, что при этом ничего не выделено, чтобы избежать возможного восприятия компьютером как команды «Копировать».

Чтобы избежать ожидания завершения длительных задач и сразу перейти к следующим, можно запустить задачи в фоновом режиме. Для этого используется командлет

Start-Job

, а сам код задачи заключается в фигурные скобки:

Start-Job {Get-ChildItem -Path C:\ -Name powershell.exe -Recurse -ErrorAction SilentlyContinue}

![запуск задачи в фоновом режиме в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-skobki-1024x144.jpg)

Параллельно возможно выполнение любого числа фоновых задач. В дополнение к командлету

Start-Job

, предназначенному для управления фоновыми задачами, существуют и другие командлеты:

- Get-Job
    
    предоставляет отчет о состоянии фоновых задач.
- Wait-Job
    
    блокирует консоль до завершения фоновой задачи.
- Stop-Job
    
    прекращает выполнение фоновой задачи.
- Receive-Job
    
    выводит результаты выполнения фоновой задачи и очищает их из памяти. Для сохранения результатов в памяти используйте параметр
    
    -Keep
    
    .

Опции

Wait-Job

,

Stop-Job

и

Receive-Job

требуют указания имени

Name

или идентификатора

Id

конкретной задачи или задач (в случае нескольких). Это можно сделать непосредственно или в связке с командлетом

Get-Job

.

Get-Job Job1

![выполнение команды get job для отчета о состоянии фоновой задачи](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-job-1024x158.jpg)

## Работа с файлами

PowerShell предоставляет удобные средства для работы с файлами. Вот некоторые ключевые методы:

Для **создания файла** используйте командлет

New-Item

с указанием пути к файлу:

New-Item -Path "C:\путь\к\файлу\новыйфайл.txt" -ItemType File

Чтобы **записать данные в файл**, используйте

Out-File

или

Set-Content

:

"Содержимое файла" | Out-File -FilePath "C:\путь\к\файлу\новыйфайл.txt"

Set-Content -Path "C:\путь\к\файлу\новыйфайл.txt" -Value "Новое содержимое файла"

Для **чтения содержимого файла** в массив используйте

Get-Content

:

$содержимое = Get-Content -Path "C:\путь\к\файлу\новыйфайл.txt"

Для **получения информации о файле** (размер, дата создания и др.) используйте

Get-Item

:

$информацияОФайле = Get-Item -Path "C:\путь\к\файлу\новыйфайл.txt"

Для **копирования файла** в другое место используйте

Copy-Item

:

Copy-Item -Path "C:\путь\к\файлу\новыйфайл.txt" -Destination "C:\путь\к\копия\новыйфайл.txt"

Для **удаления файла** воспользуйтесь командлетом

Remove-Item

:

Remove-Item -Path "C:\путь\к\файлу\новыйфайл.txt" -Force

Помните, что операции удаления файлов необратимы, поэтому будьте осторожны при их использовании.

## Работа в PowerShell ISE

Командная оболочка PowerShell представляет собой удобный инструмент для выполнения малых, кратких однострочных задач. Однако для создания и сохранения более сложных сценариев существует интегрированная среда разработки скриптов **PowerShell ISE**.

![Интерфейс среды разработки скриптов PowerShell ISE](https://lh3.googleusercontent.com/s4ab3s4HZ82r92-_zqGVQlyYuhuFVEpgFMEqWKIiHPRaPCzGx6n-IeYXfRAEHoA8GIevlugZLwOR6fW4Hba8n5I5Mv0kx4_aTRYGGJQ9GVsYffWC3d8xx6CENUagKA0IPQO9Yr06ATup1V8QHHhVVMM)

#### **ИМЕЙТЕ В ВИДУ!**  
  
PowerShell ISE предназначен для работы с версиями языка до 5.1 включительно. Однако для более новых версий Microsoft рекомендует использовать [Visual Studio Code](https://blog.skillfactory.ru/glossary/visual-studio-code/) с установленным расширением PowerShell.

PowerShell ISE представляет собой инструмент, состоящий из трех основных панелей:

- Область скриптов в верхней части экрана, предназначенная для написания сценариев.
- Консольная область в нижней части экрана, которая функционирует как обычный терминал, позволяя вводить команды в интерактивном режиме.
- Панель команд в правой части экрана, предоставляющая полное руководство по командам PowerShell. В ней также есть конструктор, который помогает задать значения нужных параметров.

### Комментарии в коде

В PowerShell имеется возможность включать комментарии в код, которые не влияют на выполнение сценария, но предназначены для читаемости программы другими людьми. Однострочный комментарий начинается с символа

#

, а многострочный комментарий заключается между символами

<#

и

#>

.

Вот пример PowerShell скрипта с комментариями:

# Это комментарий в одну строку, начинается с символа '#' и продолжается до конца строки.

# Пример переменной

$имя = "John"

$возраст = 30

# Вывод информации

Write-Host "Привет, $имя! Тебе $возраст лет."

# Это многострочный комментарий, который начинается с '<#' и заканчивается '#>'.

<#

Этот блок комментария может быть многострочным и располагаться

на нескольких строках, чтобы объяснить более сложные участки кода.

#>

# Функция для сложения двух чисел

function Сложить-Числа {

param(

[int]$число1,

[int]$число2

)

$результат = $число1 + $число2

return $результат

}

# Вызов функции и вывод результата

$результатСложения = Сложить-Числа -число1 5 -число2 7

Write-Host "Результат сложения: $результатСложения"

**Хорошая практика — комментировать код** таким образом, чтобы другие разработчики (или вы в будущем) могли легко понять, как работает код и какие цели преследовались при его написании.

### Советы по написанию хорошего кода:

- **Применяйте нотацию PascalCase** для названий командлетов, функций, параметров, свойств, методов, переменных и классов. Разработчики Powershell выпустили для этого [гайд](https://github.com/PoshCode/PowerShellPracticeAndStyle). **Не рекомендуется:**
    
    get-service
    
    ,
    
    Get-service
    
    ,
    
    GET-SERVICE
    
    . **Рекомендуется:**
    
    Get-Service
    
    .
- **Используйте полные названия командлетов.** Алиасы удобны для интерактивного режима, но в скриптах они могут затруднить понимание. **Не рекомендуется:**
    
    dir
    
    ,
    
    gci
    
    ,
    
    ls
    
    . **Рекомендуется:**
    
    Get-ChildItem
    
    .
- **Применяйте стиль One True Brace для форматирования вложенных блоков кода.** Если вы используете фигурные скобки, внутренний код отделяется табуляцией (четыре пробела), а фигурные скобки размещаются следующим образом:

if ($var1 -eq $var2) {

# Код внутри условия

} else {

# Код внутри else

# Еще код внутри else

}

Исключение: когда код внутри фигурных скобок небольшой, его можно записать в одну строку:

Get-ChildItem | Where-Object { $_.Length -gt 10mb }

### Запуск скриптов

В PowerShell ISE имеется возможность выполнять код как целиком, так и частично, а также предоставляются инструменты для отладки. Скрипты сохраняются в файлах с расширением `**.ps1**`. Однако запустить скрипт, просто дважды щелкнув по нему, не получится. Вместо этого вы можете нажать правую кнопку мыши и выбрать опцию `**Выполнить с помощью PowerShell**`.

Также существует возможность запуска скрипта из оболочки. Например, предположим, у вас есть файл скрипта **test_script.ps1** в каталоге `**C:\Scripts**`. Вы можете выполнить его двумя способами:

1. Используя команду
    
    PowerShell -File C:\Scripts\test_script.ps1
    
    из любого места. Это позволяет запустить скрипт, указав полный путь к файлу.
2. Используя команду
    
    .\test_script.ps1
    
    , если вы находитесь в каталоге `**C:\Scripts**`. Это запустит скрипт, находясь в том же каталоге, что и файл скрипта.

Такие методы позволяют управлять выполнением PowerShell скриптов из разных мест и с разных уровней оболочки.

### Политика выполнения. Как разрешить выполнения скриптов

По умолчанию запрещено выполнение файлов с PowerShell-скриптами, и это сделано с целью обеспечения безопасности. Вы можете узнать текущую политику выполнения с помощью командлета

Get-ExecutionPolicy

. Вот какие варианты политики выполнения могут быть доступны:

- **Restricted** (Установлена по умолчанию) — запрещено выполнение любых скриптов. Это означает, что нельзя будет запустить ни один скрипт.
- **AllSigned** — разрешено выполнение только тех скриптов, которые были подписаны доверенным разработчиком. Это обеспечивает повышенный уровень безопасности, так как только подписанные и проверенные скрипты могут быть выполнены.
- **RemoteSigned** — разрешено выполнение подписанных доверенным разработчиком скриптов, а также собственных скриптов. Это предоставляет баланс между безопасностью и удобством, позволяя запускать свои скрипты.
- **Unrestricted** — разрешено выполнение любых скриптов без каких-либо ограничений. Это предоставляет наивысший уровень гибкости, но может повысить риск безопасности.

Выбор политики выполнения зависит от вашей ситуации и потребностей. Учтите, что уровень безопасности можно поднять, ослабить или настроить для определенных директорий с помощью командлетов

Set-ExecutionPolicy

и

Unblock-File

.

Чтобы ваши файлы с расширением **.ps1** запускались, вам следует изменить политику выполнения на **RemoteSigned**. Для этого выполните следующие шаги:

- Откройте PowerShell от имени администратора. Для этого щелкните правой кнопкой мыши по значку PowerShell на панели задач или в меню «Пуск» и выберите «**Запуск от имени администратора**».
- В открывшемся окне PowerShell введите следующую команду и нажмите **Enter**:

Set-ExecutionPolicy RemoteSigned

- Подтвердите изменение политики выполнения, нажав клавишу **`Y`** (Yes).

Теперь вы сможете запускать свои файлы .ps1 без ограничений. Однако, имейте в виду, что изменение политики выполнения может повлиять на безопасность системы, поэтому будьте осторожны и убедитесь, что вы запускаете только те скрипты, которые вы знаете и доверяете.

## Переменные

Для сохранения данных и обращения к ним в будущем в PowerShell используются переменные. ==**Перед названием переменной ставится символ доллара**==

**$**

**, и переменные могут содержать латинские буквы (как заглавные, так и строчные), цифры и символ нижнего подчеркивания.**

Переменные в могут хранить данные различных типов, и значения в них можно изменять (перезаписывать).

![объявление переменной и ее вызов в powershell ise](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-peremennie.jpg)

Создадим переменную со строкой `2023` и преобразуем её в число. Для того чтобы узнать тип данных, воспользуемся методом

.GetType()

:

$stringValue = "2023"

$intValue = [int]$stringValue

$intValue.GetType()

Этот код создает переменную

$stringValue

со значением `2023`, затем преобразует её в число

$intValue

с помощью

[int]

. После этого вызывается метод

.GetType()

для переменной

$intValue

, чтобы **определить её тип данных**.

![определение переменной в powershell](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-tip-peremennoy.jpg)

Для **удаления переменной** используется метод

.Clear()

.

Переменные можно **вставлять в строки**, если строки оформлены двойными кавычками. В случае одинарных кавычек, PowerShell воспринимает символы в строке буквально. Давайте сравним два примера:

$number = 42

Write-Host "The number is $number" # Вывод: The number is 42

Write-Host 'The number is $number' # Вывод: The number is $number

В первом случае, используя двойные кавычки, значение переменной

$number

подставляется в строку. Во втором случае, с использованием одинарных кавычек, строка остается буквальной, и

$number

не интерпретируется как переменная.

Кроме пользовательских переменных, существуют и **системные переменные**. Например,

$PSVersionTable

содержит информацию о версии PowerShell.

![узнать версию powershell с помощью системной переменной PSVersionTable](https://blog.skillfactory.ru/wp-content/uploads/2023/08/powershell-versia.jpg)

## Логические операторы

В PowerShell вы также можете выполнять арифметические операции над объектами и строками, сравнивать их друг с другом, используя логические операторы.

**Арифметические операторы:**

- +
    
    — сложение;
- -
    
    — вычитание;
- *
    
    — умножение;
- /
    
    — деление;
- %
    
    — деление по модулю;
- (
    
    и
    
    )
    
    — скобки для группировки операций.

**Операторы сравнения** оформляются так же, как параметры командлетов, и их названия произошли от английских выражений, указанных в скобках:

- -eq
    
    — равно (от «**eq**ual»);
- -ne
    
    — не равно (от «**n**ot **e**qual»);
- -gt
    
    — больше (от «**g**reater **t**han»);
- -ge
    
    — больше либо равно (от «**g**reater than or **e**qual»);
- -lt
    
    — меньше (от «**l**ess **t**han»);
- -le
    
    — меньше либо равно (от «**l**ess than or **e**qual»).

## Работа со строками в PowerShell

PowerShell — мощный инструмент для автоматизации задач на платформе Windows. Работа со строками играет важную роль при обработке текстовых данных. Вот некоторые ключевые аспекты:

1. **Объединение строк:** Чтобы объединить строки, используйте оператор
    
    +
    
    или метод
    
    .Concat()
    
    . Пример:

$firstString = "Привет, "

$secondString = "мир!"

$combinedString = $firstString + $secondString

2. **Форматирование строк:** Используйте оператор
    
    -f
    
    или метод
    
    .Format()
    
    для вставки значений в строку. Пример:

$name = "Alice"

$age = 30

$formattedString = "Привет, меня зовут {0} и мне {1} лет." -f $name, $age

3. **Интерполяция строк:** С помощью символа
    
    $
    
    и фигурных скобок
    
    {}
    
    можно вставлять значения переменных в строки. Пример:

$city = "Москва"

$interpolatedString = "Я живу в городе $($city)."

4. **Разделение строк:** Метод
    
    .Split()
    
    используется для разделения строки на подстроки. Пример:

$text = "яблоко,груша,банан"

$fruits = $text.Split(",")

5. **Замена подстрок:** С помощью метода
    
    .Replace()
    
    можно заменить подстроку в строке. Пример:

$text = "Привет, мир!"

$modifiedText = $text.Replace("мир", "вселенная")

6. **Обрезка строк:** Методы
    
    .Trim()
    
    ,
    
    .TrimStart()
    
    и
    
    .TrimEnd()
    
    удаляют пробелы и другие символы в начале и конце строки.

Примеры использования методов для обрезки строк в PowerShell:

# Обрезка пробелов в начале и конце строки

$rawString = " Пример строки с пробелами "

$trimmedString = $rawString.Trim()

Write-Host "Исходная строка: '$rawString'"

Write-Host "Обрезанная строка: '$trimmedString'"

# Обрезка только в начале строки

$leftTrimmedString = $rawString.TrimStart()

Write-Host "Строка после обрезки в начале: '$leftTrimmedString'"

# Обрезка только в конце строки

$rightTrimmedString = $rawString.TrimEnd()

Write-Host "Строка после обрезки в конце: '$rightTrimmedString'"

При выполнении этого кода в консоли PowerShell вы увидите следующий вывод:

```
Исходная строка: '   Пример строки с пробелами   '
Обрезанная строка: 'Пример строки с пробелами'
Строка после обрезки в начале: 'Пример строки с пробелами   '
Строка после обрезки в конце: '   Пример строки с пробелами'
```

В данном примере видно, как методы

.Trim()

,

.TrimStart()

и

.TrimEnd()

удаляют пробелы в начале и конце строки, соответственно.

## Условия

Условные операторы в PowerShell создаются с использованием ключевых слов **`if`**, **`elseif`** и **`else`**. В круглых скобках указывается само условие, а в фигурных скобках содержится код, который выполняется при выполнении условия. Например:

$Number = 123

if ($Number -gt 0) {

Write-Host 'Число больше нуля'

} elseif ($Number -lt 0) {

Write-Host 'Число меньше нуля'

} else {

Write-Host 'Число равно нулю'

}

Результат выполнения кода: Число больше нуля

Кроме того, условия также можно задавать с помощью ключевого слова **`switch`**. Например:

$Day = 5

switch ($Day) {

1 { Write-Host 'Понедельник' }

2 { Write-Host 'Вторник' }

3 { Write-Host 'Среда' }

4 { Write-Host 'Четверг' }

5 { Write-Host 'Пятница' }

6 { Write-Host 'Суббота' }

7 { Write-Host 'Воскресенье' }

}

Результат выполнения кода: Пятница

## Циклы

В PowerShell существует несколько видов циклов:

- Цикл с предусловием
    
    while
    
    :

$counter = 0

while ($counter -lt 5) {

Write-Host "Counter is $($counter)"

$counter++

}

- Цикл с постусловием истинным
    
    do while
    
    :

$counter = 0

do {

Write-Host "Counter is $($counter)"

$counter++

} while ($counter -lt 5)

- Цикл с постусловием ложным
    
    do until
    
    :

$counter = 0

do {

Write-Host "Counter is $($counter)"

$counter++

} until ($counter -ge 5)

- Цикл с известным числом итераций
    
    for
    
    :

for ($i = 0; $i -lt 5; $i++) {

Write-Host "Iteration is $i"

}

- Цикл с перебором элементов коллекции
    
    foreach
    
    :

$numbers = 1..5

foreach ($num in $numbers) {

Write-Host "Number is $num"

}

Во всех случаях синтаксис похож на синтаксис условных операторов: ==в круглых скобках указывается условие или параметры, а в фигурных скобках — код, который выполняется внутри цикла.==

## Массивы, хеш-таблицы, функции и классы

В PowerShell есть множество возможностей для создания сложных структур данных и алгоритмов. Вот краткое описание некоторых из них:

- **Массивы** (Arrays): позволяют хранить набор элементов одного типа. Элементы могут быть доступны по индексам. Создаются массивы с использованием квадратных скобок `**[ ]**`.

$fruits = "Apple", "Banana", "Orange"

$fruits[0] # Доступ к элементу массива по индексу

- **Хеш-таблицы** (Hash Tables): представляют собой пары ключ-значение, где ключи уникальны. Они полезны для хранения и быстрого доступа к данным по ключу.

$person = @{

Name = "John"

Age = 30

City = "New York"

}

$person["Name"] # Доступ к значению по ключу

- **Пользовательские функции**: Вы можете определить собственные функции для группировки кода и повторного использования. Их определение происходит с использованием ключевого слова **`function`**.

function Get-Sum {

param($a, $b)

return $a + $b

}

$result = Get-Sum 5 3

- **Пользовательские классы**: PowerShell также поддерживает создание пользовательских классов, что позволяет создавать более сложные объекты с различными свойствами и методами.

class Person {

[string] $Name

[int] $Age

Person([string] $name, [int] $age) {

$this.Name = $name

$this.Age = $age

}

[string] GetInfo() {

return "$($this.Name), $($this.Age) years old"

}

}

$person = [Person]::new("Alice", 25)

$info = $person.GetInfo()

Это всего лишь краткий обзор, и в документации PowerShell можно найти более подробную информацию и примеры использования этих и других возможностей для создания более сложных структур данных и алгоритмов:

- [Массивы](https://learn.microsoft.com/ru-ru/powershell/scripting/lang-spec/chapter-09)
- [Хеш-таблицы](https://learn.microsoft.com/ru-ru/powershell/scripting/lang-spec/chapter-10)
- [Пользовательские функции](https://learn.microsoft.com/ru-ru/powershell/scripting/learn/ps101/09-functions)
- [Пользовательские классы](https://learn.microsoft.com/ru-ru/powershell/module/microsoft.powershell.core/about/about_classes)

## Для чего нужен PowerShell

PowerShell — это мощный инструмент для автоматизации задач, управления операционной системой и взаимодействия с различными приложениями и сервисами. Он широко используется администраторами систем, разработчиками, а также специалистами в области IT для решения разнообразных задач. Вот некоторые из основных применений PowerShell:

1. **Автоматизация задач**: PowerShell позволяет создавать сценарии (скрипты) для автоматизации повторяющихся и рутинных задач, таких как установка программ, настройка системных параметров, копирование файлов и многие другие операции.
2. **Управление системой**: PowerShell предоставляет доступ к широкому спектру системных функций, позволяя администраторам управлять пользователями, группами, службами, процессами, реестром и другими системными ресурсами.
3. **Конфигурация и развертывание**: С помощью PowerShell можно создавать и применять конфигурации для развертывания и управления серверами и компьютерами, что делает процесс управления парком устройств более эффективным.
4. **Мониторинг и анализ**: PowerShell позволяет анализировать системные данные, собирать статистику, мониторить производительность и события, что помогает администраторам быстро реагировать на проблемы.
5. **Взаимодействие с внешними приложениями и службами**: PowerShell может взаимодействовать с другими приложениями и службами, используя API, веб-службы, REST API и другие протоколы, что позволяет автоматизировать процессы, связанные с сторонними приложениями.
6. **Разработка и тестирование**: Разработчики используют PowerShell для создания сценариев тестирования, сборки проектов, управления версиями и других задач, связанных с разработкой ПО.
7. **Обработка данных**: PowerShell предоставляет мощные инструменты для обработки и анализа данных, таких как текстовые файлы, CSV, [XML](https://blog.skillfactory.ru/glossary/xml/) и другие форматы данных.
8. **Безопасность**: PowerShell может использоваться для управления политиками безопасности, мониторинга событий безопасности, а также для проведения аудитов безопасности системы.

## Чем PowerShell отличается от cmd

Рассмотрим сравнение двух основных инструментов командной строки в операционной системе Windows: PowerShell и командной строки (cmd). Оба инструмента позволяют взаимодействовать с операционной системой через команды и сценарии, однако они существенно различаются по своим характеристикам и функциональности.

|Аспект|PowerShell|Командная строка (cmd)|
|---|---|---|
|Язык сценариев|Мощный язык на основе .NET Framework|Ограниченный язык для выполнения команд|
|Объектная модель|Работа с объектами и конвейерная обработка|Работа с текстовыми строками и потоками|
|Управление системой|Обширный набор командлетов для управления|Ограниченный набор команд для управления|
|Синтаксис|Современный и читаемый синтаксис|Простой синтаксис команд и аргументов|
|Поддержка модулей|Поддержка модулей для организации функциональности|Отсутствие концепции модулей|

Таблица сравнения PowerShell и cmd.

## Итоги

Windows PowerShell представляет собой программу и язык программирования, который применяется для управления операционными системами и автоматизации операций. Этот инструмент поддерживает концепции объектно-ориентированного программирования и обеспечивает возможность взаимодействия в интерактивном режиме, а также создания, сохранения и выполнения разнообразных скриптов.

- PowerShell изначально **интегрирован в операционную систему Windows версий 7, 8, 10, 11 и Server**, но также доступен для скачивания на платформах macOS и Linux. В дополнение к этому, для более старых версий языка (5.1 и ранее) имеется инструмент под названием PowerShell ISE — интегрированная среда сценариев.
- Центральной концепцией PowerShell является работа с **объектами**, а не с простыми строками. Взаимодействие с объектами осуществляется через **командлеты**, построенные в соответствии с принципом «Глагол-Существительное».
- Сила PowerShell заключается в возможности передачи результатов выполнения одного командлета в качестве входных данных для другого, используя **конвейер**. Этот подход способствует более эффективной и гибкой обработке данных.
- Помимо этого, PowerShell предоставляет функциональность для выполнения задач в **фоновом режиме**, что позволяет параллельно выполнять несколько операций.
- PowerShell является высокоуровневым языком программирования, который обеспечивает возможность работы с переменными, логическими операторами, условиями, циклами, массивами, хеш-таблицами, функциями и классами.

https://youtu.be/-5u8m—A1gQ

_Видео-туториал по Windows Powershell_