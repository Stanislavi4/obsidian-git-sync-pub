---
created: 2024-02-22T03:46:22 (UTC +06:00)
tags: [unix,linux,terminal,bash,инструкция,сводка,советы,github]
source: https://habr.com/ru/articles/262127/#zen
author: Олег Берман
---

# Искусство командной строки / Хабр

> ## Excerpt
> Вот уже как неделю английская версия the art of command line висит в секции trending на Github. Для себя я нашел этот материал невероятно полезным и решил помо...

---
![](%D0%98%D1%81%D0%BA%D1%83%D1%81%D1%81%D1%82%D0%B2%D0%BE%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%BE%D0%B9%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8%20%20%D0%A5%D0%B0%D0%B1%D1%80/7d6ec6090066518746d473fc99a80ba7.png)

Вот уже как неделю английская версия **the art of command line** висит в секции trending на Github. Для себя я нашел этот материал невероятно полезным и решил помочь сообществу его переводом на русский язык. В переводе наверняка есть несколько недоработок, поэтому милости прошу слать пулл-реквесты мне [сюда](https://github.com/olegberman/the-art-of-command-line) или автору оригинальной работы [Joshua Levy](https://github.com/jlevy) [вот сюда](https://github.com/jlevy/the-art-of-command-line). (Если PR отправите мне, то я после того, как пересмотрю изменения отправлю их в мастер-бранч Джоша). Отдельное спасибо [jtraub](https://habrahabr.ru/users/jtraub/) за помощь и исправление опечаток.

(_[тсс, в маркдауне читабельнее](https://github.com/jlevy/the-art-of-command-line/blob/master/README-ru.md)_)

-   [Описание](https://habr.com/ru/articles/262127/#desc)
-   [Основы](https://habr.com/ru/articles/262127/#basic)
-   [Ежедневное использование](https://habr.com/ru/articles/262127/#erryday)
-   [Процессинг файлов и информации](https://habr.com/ru/articles/262127/#proc)
-   [Системный дебаггинг](https://habr.com/ru/articles/262127/#deep)
-   [В одну строчку](https://habr.com/ru/articles/262127/#line)
-   [Сложно, но полезно](https://habr.com/ru/articles/262127/#zen)
-   [MacOS only](https://habr.com/ru/articles/262127/#osx)
-   [Больше информации по теме](https://habr.com/ru/articles/262127/#moar)
-   [Дисклеймер](https://habr.com/ru/articles/262127/#claimer)

  

## Описание

Основное:

  

-   Данная публикация предназначена как для новичков, так и для опытных людей. Цели: _объемность_ (собрать все важные аспекты использования командной строки), _практичность_ (давать конкретные примеры для самых частых юзкейсов) и _краткость_ (не стоит углубляться в неочевидные вещи, о которых можно почитать в другом месте).
-   Этот документ написан для пользователей Linux, с единственным исключеним – секцией “[MacOS only](https://habr.com/ru/articles/262127/#macos-only)“. Все остальное подходит и может быть установлено под все UNIX/MacOS системы (и даже Cygwin).
-   Фокусируемся на интерактивном Баше, но многие вещи так же могут быть использованы с другими шеллами; и в общем применимы к Баш-скриптингу
-   Эта инструкция включает в себя стандартные Unix команды и те, для которых нужно устанавливать сторонние пакеты – они настолько полезны, что стоят того, чтобы их установили

Заметки:

  

-   Для того, чтобы руководство оставалось одностраничным, вся информация вставлена прямо сюда. Вы достаточно умные для того, чтобы самостоятельно изучить вопрос более детально в другом месте. Используйте _apt-get_/_yum_/_dnf_/_pacman_/_pip_/_brew_ (в зависимости от вашей системы управления пакетами) для установки новых программ.
    
-   На [Explainshell](http://explainshell.com/) можно найти простое и детальное объясение того, что такое команды, флаги, пайпы и т.д.
    

  

## Основы

-   Выучите основы Баша. Просто возьмите и напечатайте _man bash_ в терминале и хотя бы просмотрите его; он довольно просто читается и он не очень большой. Другие шеллы тоже могут быть хороши, но Баш – мощная программа и Баш всегда под рукой (использование _исключительно_ zsh, fish и т.д., которые наверняка круто выглядят на Вашем ноуте во многом Вас ограничивает, например Вы не сможете использовать возможности этих шеллов на уже существующем сервере).
    
-   Выучите хотя бы один консольный редактор текста. Идеально Vim (_vi_), ведь у него нет конкурентов, когда вам нужно быстренько что-то подправить (даже если Вы постоянно сидите на Emacs/какой-нибудь тяжелой IDE или на каком-нибудь модном хипстерском редакторе)
    
-   Знайте как читать документацию через _man_ (для любознательных – _man man_; _man_ по углам документа в скобках добавляет номер, например 1 – для обычных команд, 5 – для файлов, конвенций, 8 – для административных команд). Ищите мануалы через _apropos_, и помните, что некоторые команды – не бинарники, а встроенные команды Баша, и помощь по ним можно получить через _help_ и _help -d_.
    
-   Узнайте о том, как перенаправлять ввод и вывод через _\>_ и _<_ и пайпы _|_. Помните, что _\>_ – переписывает выходной файл, а _\>>_ добавляет к нему. Узнайте побольше про stdout and stderr.
    
-   Узнайте побольше про file glob expansion with _\*_ (and perhaps _?_ and _{_…_}_), кавычки а так же разницу между двойными _"_ и одинарными _'_ кавычками. (Больше о расширении переменных читайте ниже)
    
-   Будьте знакомы с работой с процессами в Bash: _&_, **ctrl-z**, **ctrl-c**, _jobs_, _fg_, _bg_, _kill_, и т.д.
    
-   Знайте _ssh_, и основы безпарольной аунтефикации через _ssh-agent_, _ssh-add_, и т.д.
    
-   Основы работы с файлами: _ls_ и _ls -l_ (в частности узнайте, что значит каждый столбец в _ls -l_), _less_, _head_, _tail_ и _tail -f_ (или даже лучше, _less +F_), _ln_ и _ln -s_ (узнайте разницу между символьными ссылками и жесткими ссылками и почему жесткие ссылки лучше), _chown_, _chmod_, _du_ (для быстрой сводки по использованию диска: _du -hk \*_). Для менеджмента файловой системы, _df_, _mount_, _fdisk_, _mkfs_, _lsblk_.
    
-   Основы работы с сетью: _ip_ или _ifconfig_, _dig_.
    
-   Хорошо знайте регулярные выражения и разные флаги к _grep_/_egrep_. Такие флаги как _\-i_, _\-o_, _\-A_, и _\-B_ стоит знать.
    
-   Обучитесь использованию системами управления пакетами _apt-get_, _yum_, _dnf_ или _pacman_ (в зависимости от дистрибутива). Знайте как искать и устанавливать пакеты и обязательно имейте установленым _pip_ для установки командных утилит, написаных на Python (некоторые из тех, что вы найдете ниже легче всего установить через _pip_)
    

  

## Ежедневное использование

-   Используйте таб в Баше для автокомплита аргументов к командам и **ctrl-r** для поиска по истории командной строки
    
-   Используйте **ctrl-w** в Баше для того, чтобы удалить последнее слово в команде; **ctrl-u** для того, что бы удалить команду полностью. Используйте **alt-b** и **alt-f** для того, чтобы бегать между словами команды, **ctrl-k** для того, чтобы прыгнуть к концу строки, **ctrl-l** для того, чтобы очистить экран. Гляньте на _man readline_ чтобы узнать о всех шорткатах Баша. Их много! Например, **alt-.** бежит по предыдущим аргументам команды, а **alt-\*** расширяет глоб.??
    
-   Если Вам нравятся шорткаты Вима сделайте _set -o vi_.
    
-   Для того, чтобы посмотреть историю введите _history_. Так же существует множество аббривиатур, например _!$_ – последний аргумент, _!!_ – последняя команда, хотя эти аббревиатуры часто заменяются шорткатами **ctrl-r** и **alt-.**.
    
-   Для того, чтобы прыгнуть к последней рабочей директории – _cd -_
    
-   Если Вы написали команду наполовину и вдруг передумали нажмите **alt-#** для того, чтобы добавить _#_ к началу и отправьте команду как комментарий. Потом вы сможете вернуться к ней через историю.
    
-   Не забывайте использовать _xargs_ (или _parallel_). Это очень мощная штука. Обратите внимание, что Вы можете контролировать количество команд на каждую строку, а так же параллельность. Если Вы не уверены, что делаете что-то правильно, начните с _xargs echo_. Еще _\-I{}_ – полезная штука. Примеры:
    

  

```
      find . -name '*.py' | xargs grep some_function
      cat hosts | xargs -I{} ssh root@{} hostname
```

  

-   _pstree -p_ – полезный тип вывода дерева процессов.
    
-   Используйте _pgrep_ или _pkill_ для того чтобы находить/слать сигналы к процессам по имени (_\-f_ помогает).
    
-   Знайте разные сигналы, которые можно слать процессам. Например, чтобы приостановить процесс используйте _kill -STOP \[pid\]_. Для полного списка посмотрите _man 7 signal_.
    
-   Используйте _nohup_ или _disown_ для того, чтобы процесс в фоне выполнялся бесконечно.
    
-   Узнайте какие процессы слушают порты через _netstat -lntp_ или _ss -plat_ (для TCP; добавьте _\-u_ для UDP).
    
-   Так же _lsof_ для того, чтобы посмотреть открытые сокеты и файлы.
    
-   Используйте _alias_ для того, чтобы алиасить часто используемые команды. Например, _alias ll='ls -latr'_ создаст новый алиас _ll_.
    
-   В Баш скритах используйте _set -x_ для того, чтобы дебажить аутпут. Используйте строгие режимы везде, где возможно. Используйте _set -e_ для того, чтобы прекращать выполнение при ошибках. Используйте _set -o pipefail_ для того, чтобы строго относится к ошибкам (это немного глубокая тема). Для более сложных скриптов так же используйте _trap_.
    
-   В Баш скриптах, подоболочки (subshells) – удобный способ группировать команды. Один из самых распространенных примеров – временно передвинуться в другую рабочую директорию, вот так:
    

  

```
  # do something in current dir
  (cd /some/other/dir &amp;&amp; other-command)
  # continue in original dir
```

  

-   В Баше много типов пространства переменных. Проверить, существует ли переменная – _${name:?error message}_. Например, если Баш-скрипту нужен всего один аргумент просто напишите _input\_file=${1:?usage: $0 input\_file}_. Арифметическая область видимости: _i=$(( (i + 1) % 5 ))_. Последовательности: _{1..10}_. Обрезка строк: _${var%suffix}_ и _${var#prefix}_. Например, если _var=foo.pdf_ тогда _echo ${var%.pdf}.txt_ выведет _foo.txt_.
    
-   Вывод любой команды можно обратить в файл через _<(some command)_. Например, сравнение локального файла \`/etc/hosts с удаленным:
    

  

```
diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)
```

  

-   Знайте про heredoc-синтаксис в Баше, работает он вот так _cat <<EOF ..._.
    
-   В Баше перенаправляйте стандартный вывод, а так же стандартные ошибки вот так: _some-command >logfile 2>&1_. Зачастую для того, чтобы убедится, что команда не оставит открытым файл, привязав его к открытому терминалу считается хорошей практикой добавлять _</dev/null_.
    
-   Используйте _man ascii_ для хорошей ASCII таблицы, с hex и десятичными значениями. Для информации по основным кодировкам полезны: _man unicode_, _man utf-8_, и _man latin1_.
    
-   Используйте _screen_ или [_tmux_](https://tmux.github.io/) для того, чтобы иметь несколько экранов в одном терминале, это особенно полезно, когда вы работаете с удаленным сервером, тогда Вы можете подключаться/отключаться от сессий. Более минималистичный подход для этого – использование _dtach_.
    
-   В SSH полезно знать как port tunnel с флагами _\-L_ и _\-D_ (и иногда _\-R_), например для того, чтобы зайти на сайт с удаленного сервера.
    
-   Еще может быть полезно оптимизировать вашу SSH конфигурацию, например этот файл _~/.ssh/config_ содержит настройки, которые помогают избегать потерянные подключения в некоторых сетевых окружениях, используйте сжатие (которое полезно с scp через медленные подключения) и увеличьте количество каналов к одному серверу через этот конфиг вот так:
    

  

```
TCPKeepAlive=yes
ServerAliveInterval=15
ServerAliveCountMax=6
Compression=yes
ControlMaster auto
ControlPath /tmp/%r@%h:%p
ControlPersist yes
```

  

-   Некоторые другие настройки SSH могут сильно повлиять на безопасность и должны меняться осторожно, например для конкретной подсети или конкретной машины или в домашних сетях: _StrictHostKeyChecking=no_, _ForwardAgent=yes_
    
-   Для того, чтобы получить разрешения файла в восьмеричном виде, что полезно для конфигурации систем, но нельзя получить из _ls_, можно использовать что-то типа:
    

  

```
  stat -c '%A %a %n' /etc/timezone
```

  

-   Для интерактивного выделения результатов других команд используйте [_percol_](https://github.com/mooz/percol) or [_fzf_](https://github.com/junegunn/fzf).
    
-   Для работы с файлами, список которых дала другая команда (например Git) используйте _fpp_ ([PathPicker](https://github.com/facebook/PathPicker)).
    
-   Для того чтобы быстро поднять веб-сервер в текущей директории (и поддерикториях), который доступен для всех в вашей сети используйте:  
    _python -m SimpleHTTPServer 7777_ (for port 7777 and Python 2) and _python -m http.server 7777_ (for port 7777 and Python 3).
    
-   Для того, чтобы выполнить определенную команду с привилегиями, используйте _sudo_ (для рута) и _sudo -u_ (для другого пользователя). Используйте _su_ или _sudo bash_ для того чтобы запустить шелл от имени этого пользователя. Используйте _su -_ для того, чтобы симулировать свежий логин от рута или другого пользователя.
    

  

## Процессинг файлов и информации

-   Для того, чтобы найти файл в текущей директории сделайте _find. -iname '\*something\*'_. Для того, чтобы искать файл по всей системе используйте _locate something_ (но не забывайте, что _updatedb_ мог еще не проиндексировать недавно созданные файлы).
    
-   Для основого поиска по содержимому файлов (более сложному, чем _grep -r_) используйте [_ag_](https://github.com/ggreer/the_silver_searcher).
    
-   Для конвертации HTML в текст: _lynx -dump -stdin_
    
-   Для конвертации разных типов разметки (HTML, маркдаун и т.д.) попробуйте [_pandoc_](http://pandoc.org/).
    
-   Если нужно работать с XML, есть старая но хорошая утилита – _xmlstarlet_.
    
-   Для работы с JSON используйте _jq_.
    
-   Для работы с Excel и CSV-файлами используйте [csvkit](https://github.com/onyxfish/csvkit) (программа предоставляет команды _in2csv_, _csvcut_, _csvjoin_, _csvgrep_ и т.д.)
    
-   Для работы с Amazon S3 удобно работать с [_s3cmd_](https://github.com/s3tools/s3cmd) и [_s4cmd_](https://github.com/bloomreach/s4cmd) (последний работает быстрее). Для остальных сервисов Амазона используйте стандартный [_aws_](https://github.com/aws/aws-cli).
    
-   Знайте про _sort_ и _uniq_, включая флаги _\-u_ и _\-d_, смотрите примеры ниже. Еще гляньте на _comm_.
    
-   Знайте про _cut_, _paste_, и _join_ для работы с текстовыми файлами. Многие люди используют _cut_ забыв про _join_.
    
-   Знайте о _wc_: для подсчета переводов строк (_\-l_), для символов – (_\-m_), для слов – words (_\-w_), для байтового подсчета – (_\-c_).
    
-   Знайте про _tee_, для копирования в файл из stdin и stdout, что-то типа _ls -al | tee file.txt_.
    
-   Не забывайте, что Ваша локаль влияет на многие команды, включая порядки сортировки, сравнение и производительность. Многие дистрибутивы Linux автоматически выставляют _LANG_ или любую другую переменную в подходящую для Вашего региона. Из-за этого результаты функций сортировки могут работать непредсказуемо. Рутины _i18n_ могут значительно снизить производительность сортировок. В некоторых случаях можно полностью этого избегать (за исключением редких случаев), сортируя традиционно побайтово, для этого _export LC\_ALL=C_
    
-   Знайте основы _awk_ и _sed_ для простых манипуляций с данными. Например, чтобы получить сумму всех чисел, которые находятся в третьей колонки текстового файла можно использовать _awk '{ x += $3 } END { print x }'_. Скорее всего, это раза в 3 быстрее и раза в 3 проще чем делать это в Питоне.
    
-   Чтобы заменить все нахождения подстроки в одном или нескольких файлах:
    

  

```
  perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt
```

Для того, чтобы переименовать сразу много файлов по шаблону, используйте _rename_. Для сложных переименований может помочь [_repren_](https://github.com/jlevy/repren):

  

```
# Восстановить бекапы из foo.bak в foo:
rename 's/\.bak$//' *.bak
# Полное переименование имен файлов, папок и содержимого файлов из foo в bar.
repren --full --preserve-case --from foo --to bar .
```

  

-   Используйте _shuf_ для того, чтобы перемешать строки или выбрать случайную строчку из файла.
    
-   Знайте флаги _sort_а. Для чисел используйте _\-n_, для работы с человекочитаемыми числами используйте _\-h_ (например _du -h_). Знайте как работают ключи (_\-t_ и _\-k_). В частности, не забывайте что вам нужно писать _\-k1,1_ для того, чтобы отсортировать только первое поле; _\-k1_ значит сортировка учитывая всю строчку. Так же стабильная сортировка может быть полезной (_sort -s_). Например для того, чтобы отсортировать самое важное по второму полю, а второстепенное по первому можно использовать sort -k1,1 | sort -s -k2,2\`.
    
-   Если вам когда-нибудь придется написать код таба в терминале, например для сортировки по табу с флагом -t, используйте шорткат **ctrl-v** **\[Tab\]** или напишите _$'\\t'_. Последнее лучше, потому что его можно скопировать.
    
-   Стандартные инструменты для патчинга исходников это _diff_ и _patch_. Так же посмотрите на _diffstat_ для просмотра статистики диффа. _diff -r_ работает для по всей директории. Используйте _diff -r tree1 tree2 | diffstat_ для полной сводки изменений.
    
-   Для бинарников используйте _hd_ для простых hex-дампом и _bvi_ для двоичного изменения бинарников.
    
-   _strings_ (в связке _grep_ или чем-то похожем) помогает найти строки в бинарниках.
    
-   Для того, чтобы посмотреть разницу в бинарниках (дельта кодирование) используйте _xdelta3_.
    
-   Для конвертирования кодировок используйте _iconv_. Для более сложных задач – _uconv_, он поддерживает некоторые сложные фичи Юникода. Например эта команда переводит строки из файла в нижний регистр и убирает ударения (кои бывают, например, в Испанском)
    

  

```
  uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt
```

  

-   Для того, чтобы разбить файл на куски используйте _split_ (разбивает на куски по размеру), или _csplit_ (по шаблону или регулярному выражению)
    
-   Используйте _zless_, _zmore_, _zcat_, и _zgrep_ для работы с сжатыми файлами.
    

  

## Системный дебаггинг

-   Дле веб-дебаггинга используйте _curl_ и _curl -I_, или их альтернативу _wget_. Так же есть более современные альтернативы, типа [_httpie_](https://github.com/jakubroztocil/httpie).
    
-   Чтобы получить информацию о диске/CPU/сети используйте _iostat_, _netstat_, _top_ (или лучшую альтернативу _htop_) и особенно _dstat_. Хороший старт для того, чтобы понимать что происходит в системе.
    
-   Для более детальной информации используйте [_glances_](https://github.com/nicolargo/glances). Эта программа показывает сразу несколько разных статистик в одном окне терминале. Полезно, когда следите за сразу несколькими системами.
    
-   Для того, чтобы следить за памятью научитесь понимать _free_ и _vmstat_. В частности не забывайте, что кешированые значения (“cached” value) – это память, которую держит ядро и эти значения являются частью _free_.
    
-   Дебаггинг Джавы – совсем другая рыбка, но некоторые манипуляции над виртуальной машиной Оракла или любой другой позволит вам использовать делать _kill -3 <pid>_ и трассировать сводки стека и хипа (включая детали работы сборщика мусора, которые бывают очень полезными), и их можно дампнуть в stderr или логи.
    
-   Используйте _mtr_ для лучшей трассировки, чтобы находить проблемы сети.
    
-   Для того, чтобы узнать почему диск полностью забит используйте _ncdu_, это сохраняет время по сравнению с тем же _du -sh \*_.
    
-   Для того, чтобы узнать какой сокет или процесс использует интернет используйте _iftop_ или _nethogs_.
    
-   _ab_, которая поставляется вместе в Апачем полезна для быстрой нетщательной проверки производительности веб-сервера. Для более серьезного лоад-тестинга используйте _siege_.
    
-   Для более серьезного дебаггинга сетей используйте _wireshark_, _tshark_, и _ngrep_.
    
-   Знайте про _strace_ и _ltrace_. Эти команды могут быть полезны, если программа падает или висит и вы не знаете почему, или если вы хотите протестировать производительность программы. Не забывайте про возможность дебаггинга (_\-c_) и возможностью прицепиться к процессу (_\-p_).
    
-   Не забывайте про _ldd_ для проверки системных библиотек.
    
-   Знайте как прицепиться к бегущему процессу через _gdb_ и получить трассировку стека.
    
-   Используйте _/proc_. Иногда он невероятно полезен для дебага запущенных программ. Примеры: _/proc/cpuinfo_, _/proc/xxx/cwd_, _/proc/xxx/exe_, _/proc/xxx/fd/_, _/proc/xxx/smaps_.
    
-   Когда дебажете что-то, что сломалось в прошлом используйте _sar_ – бывает очень полезно. Показывает историю CPU, памяти, сети и т.д.
    
-   Для анализа более глубоких систем и производительности посмотрите на _stap_ ([SystemTap](https://sourceware.org/systemtap/wiki)), [_perf_](http://en.wikipedia.org/wiki/Perf_%28Linux%29), и [_sysdig_](https://github.com/draios/sysdig).
    
-   Узнайте какая у вас операционка через _uname_ or _uname -a_ (основная Unix-информация/информация о ядре) или _lsb\_release -a_ (информация о дистрибутиве).
    
-   Используйте _dmesg_ когда что-то ведет себя совсем странно (например железо или драйвера).
    

  

## В одну строчку

Давайте соберем все вместе и напишем несколько команд:

  

-   Это довольно круто, что можно найти множественные пересечения файлов, соединить отсортированные файлы и посмотреть разницу в нескольких файлов через _sort_/_uniq_. Это быстрый подход и работает на файлах любого размера (включая многогигабайтные файлы). (Сортировка не ограничена памятью, но возможно вам придется добавить _\-T_ если _/tmp_ находится на небольшом логическом диске). Еще посмотрите то что было сказано выше о _LC\_ALL_. Флаг сорта _\-u_ option не используется ниже чтобы было понятнее:

  

```
cat a b | sort | uniq &gt; c        # c is a union b
cat a b | sort | uniq -d &gt; c     # c is a intersect b
cat a b b | sort | uniq -u &gt; c   # c is set difference a - b
```

  

-   Используйте _grep. \*_ для того, чтобы посмотреть содержимое всех файлов в директории, особенно послено когда у вас много конфигов типа _/sys_, _/proc_, _/etc_.
    
-   Получить сумму всех чисел, которые находятся в третьей колонки текстового файла. (Скорее всего, это раза в 3 быстрее и раза в 3 проще чем делать это в Питоне):
    

  

```
  awk '{ x += $3 } END { print x }' myfile
```

  

-   Если вам нужно посмотреть размеры и даты создания древа файлов используйте:

  

```
find . -type f -ls
```

Это почти как рекурсивная _ls -l_, но более читабельно чем _ls -lR_:

  

-   Используйте _xargs_ (или _parallel_). Это очень мощная штука. Обратите внимание, что Вы можете контролировать количество команд на каждую строку, а так же параллельность. Если Вы не уверены, что делаете что-то правильно, начните с _xargs echo_. Еще _\-I{}_ – полезная штука. Примеры:

  

```
find . -name '*.py' | xargs grep some_function
cat hosts | xargs -I{} ssh root@{} hostname
```

  

-   Давайте представим, что у нас есть какой-то текстовый файл, например лог какого-то сервера и на каких-то строках появляется значение, строки с которой нам интересны, например _acct\_id_. Давайте подсчитаем сколько таких запросов в нашем логе:

  

```
  cat access.log | egrep -o 'acct_id=[0-9]+' | cut -d= -f2 | sort | uniq -c | sort -rn
```

  

-   Запустите этот скрипт чтобы получить случайный совет из этой инструкции:

  

```
  function taocl() {
  curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-ru.md |
    pandoc -f markdown -t html |
    xmlstarlet fo --html --dropdtd |
    xmlstarlet sel -t -v "(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]" |
    xmlstarlet unesc | fmt -80
}
```

  

## Сложно, но полезно

-   **expr**: для выполнения арифметических и булевых операций, а так же регулярных выражений
    
-   **m4**: простенький макро-процессор
    
-   **yes**: вывод строки в бесконечном цикле
    
-   **cal**: классный календарь
    
-   **env**: для того, чтобы выполнить команду (полезно в Bash-скриптах)
    
-   **printenv**: print out environment variables (useful in debugging and scripts)
    
-   **look**: найти английские слова (или строки) в файле
    
-   **cut**:, _paste_ и _join_: манипуляция данными
    
-   **fmt**: форматировка параграфов в тексте
    
-   **pr**: отформатировать текст в страницы/колонки
    
-   **fold**: (обернуть) ограничить длину строк в файле
    
-   **column**: форматировать текст в колонки или таблицы
    
-   **expand**: и _unexpand_: конвертация между табами и пробелами
    
-   **nl**: добавить номера строк
    
-   **seq**: вывести числа
    
-   **bc**: калькулятор
    
-   **factor**: возвести числа в степень
    
-   **gpg**: зашифровать и подписать файлы
    
-   **toe**: таблица терминалов terminfo с описанием
    
-   **nc**: дебаггинг сети и передачи данных
    
-   **socat**: переключатель сокетов и перенаправление tcp-портов (похоже на _netcat_)
    
-   **slurm**: визуализация трафика сети
    
-   **dd**: перенос информации между файлами и девайсами
    
-   **file**: узнать тип файла
    
-   **tree**: показать директории и сабдиректории в виде дерева; как _ls_, но рекурсивно
    
-   **stat**: информация о файле
    
-   **tac**: вывести файл наоборот (ласипан)
    
-   **shuf**: случайная выборка строк из файла
    
-   **comm**: построчно сравнить отсортированные файлы
    
-   **pv**: мониторинг прогресса прохождения информации через пайп
    
-   **hd**: и _bvi_: дамп и редактирование бинарников
    
-   **strings**: найти текст в бинарникх
    
-   **tr**: манипуляция с char (символьным типом)
    
-   **iconv**: и _uconv_: конвертация кодировок
    
-   **split**: и _csplit_: разбить файлы
    
-   **sponge**: прочитать весь инпут перед тем, как его записать, полезно когда читаешь из того же файла, куда записываешь, например вот так: _grep -v something some-file | sponge some-file_
    
-   **units**: конвертер, метры в келометры, версты в пяди (смотрите _/usr/share/units/definitions.units_)
    
-   **7z**: архиватор с высокой степенью сжатия
    
-   **ldd**: показывает зависимости программы от системных библиотек
    
-   **nm**: получаем названия всех функций, которые определены в .o или .a
    
-   **ab**: бенчмаркинг веб-серверов
    
-   **strace**: дебаг системных вызовов
    
-   **mtr**: лучшей трассировка для дебаггинга сети
    
-   **cssh**: несколько терминалов в одном UI
    
-   **rsync**: синхронизация файлов и папок через SSH
    
-   **wireshark**: и _tshark_: перехват пакетов и дебаг сети
    
-   **ngrep**: grep для слоя сети (network layer)
    
-   **host**: и _dig_: узнать DNS
    
-   **lsof**: процессинг дискрипторов и информация о сокетах
    
-   **dstat**: полезная статистика системы
    
-   [**glances**](https://github.com/nicolargo/glances): высокоуровневая, многосистемная статистика
    
-   **iostat**: статистика CPU и использования жесткого диска
    
-   **htop**: улучшенная версия top
    
-   **last**: история логинов в систему
    
-   **w**: под каким пользователем вы сидите
    
-   **id**: информация о пользователе/группе
    
-   **sar**: история системной статистики
    
-   **iftop**: или _nethogs_: использование сети конкретным сокетом или процессом
    
-   **ss**: статистика сокетов
    
-   **dmesg**: ошибки бута и ошибки системы
    
-   **hdparm**: манипуляция с SATA/ATA
    
-   **lsb\_release**: информация о дистрибутиве Linux
    
-   **lsblk**: cписок блочных устройств компьютера: древо ваших дисков и логических дисков
    
-   **lshw**:, _lscpu_, _lspci_, _lsusb_, _dmidecode_: информация о железе включая, CPU, BIOS, RAID, графику, девайсы, и т.д.
    
-   **fortune**:, _ddate_, и _sl_: хм, не знаю будут ли вам “полезны” веселые цитатки и поезда, пересекающие ваш терминал :)
    

  

## MacOS only

Некоторые вещи релевантны _только_ для Мака.

  

-   Системы управлением пакетами – _brew_ (Homebrew) и _port_ (MacPorts). Они могут быть использованы для того, чтобы установить большинство програм, упомянутых в этом документе.
    
-   Копируйте аутпут консольных программ в десктопные через _pbcopy_, и вставляйте инпут через _pbpaste_.
    
-   Для того, чтобы открыть файл или десктопную программу типа Finder используйте _open_, вот так _open -a /Applications/Whatever.app_.
    
-   Spotlight: Ищите файлы в консоле через _mdfind_ и смотрите метадату (например EXIF информацию фотографий) через _mdls_.
    
-   Не забывайте, что MacOS основан на BSD Uni и многие команды (например _ps_, _ls_, _tail_, _awk_, _sed_) имеют некоторые небольшие различия с линуксовыми. Это обусловлено влянием _UNIX System V_ и _GNU Tools_. Разницу можно заметить увидив заголовок “BSD General Commands Manual.” к манам программ. В некоторых случаях, на Мак можно поставить GNU-версии программ, например _gawk_ и _gsed_. Когда пишите кроссплатформенные Bash-скрипты, старайтесь избегать команды, которые могут различаться (например, лучше используйте Python или _perl_), или тщательно все тестируйте.
    

  

## Больше информации по теме

-   [awesome-shell](https://github.com/alebcay/awesome-shell): Дополняемый список инструментов и ресурсов для командной строки.
-   [Strict mode](http://redsymbol.net/articles/unofficial-bash-strict-mode/) Для того, чтобы писать шелл-скрипты лучше.

## Дисклеймер

За небольшим исключением, весь код написан так, что другие его смогут прочитать.

Кому много дано, с того много и спрашивается. Тот факт, что что-то может быть написано в Баше, вовсе не означает, что оно должно быть там написано. ;)

## Лицензия

[![Creative Commons License](%D0%98%D1%81%D0%BA%D1%83%D1%81%D1%81%D1%82%D0%B2%D0%BE%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%BE%D0%B9%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8%20%20%D0%A5%D0%B0%D0%B1%D1%80/074f38cade178c89ee5afa5b06e368f8.png)](http://creativecommons.org/licenses/by-sa/4.0/)

Переведено при помощи друзей из [Канады](https://ocanada.ru/).

Оригинальная работа и перевод на русский язык распространяется под лицензией [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).

[️ bootstrap.build](https://bootstrap.build/)
