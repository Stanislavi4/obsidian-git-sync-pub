---
created: 2024-02-22T04:00:40 (UTC +06:00)
tags: [Bash,Linux]
source: https://habr.com/ru/companies/ruvds/articles/445270/
author: ru_vds
---

# [в закладки] Bash для начинающих: 21 полезная команда / Хабр

> ## Excerpt
> Материал, перевод которого мы публикуем сегодня, предназначен для тех, кто хочет освоить командную строку Linux. Умение эффективно пользоваться этим инструментом...

---
Материал, перевод которого мы публикуем сегодня, предназначен для тех, кто хочет освоить командную строку Linux. Умение эффективно пользоваться этим инструментом позволяет экономить немало времени. В частности, речь здесь пойдёт о командной оболочке Bash и о 21 полезной команде. Также мы поговорим о том, как пользоваться флагами команд и псевдонимами Bash, которые позволяют ускорить ввод длинных инструкций.

[![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/803892bfe548499aa763df324d40fd01.png)](https://habrahabr.ru/company/ruvds/blog/445270/)

→ [Также читайте в нашем блоге цикл публикаций про bash-скрипты](https://habr.com/ru/company/ruvds/blog/325522/)  

## Термины

В ходе освоения работы в командной строке Linux вам может встретиться множество понятий, в которых полезно будет ориентироваться. Некоторые из них, вроде «Linux» и «Unix», или «командная оболочка» и «терминал», иногда путают. Поговорим об этих и о других важных терминах.

[Unix](https://en.wikipedia.org/wiki/Unix) — это популярная операционная система, которая была разработана Bell Labs в 1970-х. Её код был закрытым.

[Linux](https://en.wikipedia.org/wiki/Linux) — это самая популярная Unix-подобная операционная система. Она в наши дни используется на множестве устройств, в том числе — и на компьютерах.

[Терминал](https://en.wikipedia.org/wiki/Terminal_emulator) (terminal), или эмулятор терминала — это программа, дающая доступ к операционной системе. Одновременно можно открывать несколько окон терминала.

[Оболочка](https://en.wikipedia.org/wiki/Shell_%28computing%29) (shell) — это программа, которая позволяет отправлять операционной системе команды, написанные на особом языке.

[Bash](https://www.gnu.org/software/bash/) расшифровывается как Bourne Again SHell. Это — самый распространённый язык командной оболочки, используемый для взаимодействия с операционной системой. Кроме того, оболочка Bash по умолчанию используется в macOS.

[Интерфейс командной строки](https://en.wikipedia.org/wiki/Command-line_interface) (Command Line Interface, CLI) — это способ взаимодействия человека и компьютера, при использовании которого пользователь вводит команды с клавиатуры, а компьютер, выполняя эти команды, выводит, в текстовом виде, сообщения для пользователя. В основном CLI используется для получения свежей информации о неких сущностях, например, о файлах, и для работы с файлами. Интерфейс командной строки следует отличать от графического пользовательского интерфейса (Graphical User Interface, GUI), при работе с которым, в основном, используется мышь. Интерфейс командной строки часто называют просто командной строкой.

[Скрипт](https://en.wikipedia.org/wiki/Scripting_language) (script) — это небольшая программа, которая содержит последовательность команд командной оболочки. Скрипты записывают в файлы, использовать их можно многократно. При написании скриптов можно пользоваться переменными, условными конструкциями, циклами, функциями и другими возможностями.

Теперь, когда мы рассмотрели важные термины, хочу отметить, что здесь я буду пользоваться терминами «Bash», «оболочка» и «командная строка» как взаимозаменяемыми, равно как и понятиями «директория» (directory) и «папка» (folder).

Стандартные [потоки](https://en.wikipedia.org/wiki/Standard_streams), которыми мы будем здесь пользоваться — это стандартный ввод (standard input, `stdin`), стандартный вывод (standard output, `stdout`) и стандартный вывод ошибок (standard error, `stderr`).

Если в примерах команд, которые будут приводиться ниже, вы встретите нечто вроде `my_whatever` — это означает, что данный фрагмент нужно заменить чем-то вашим. Например — именем файла.

Теперь, прежде чем приступать к разбору команд, которым посвящён этот материал, давайте взглянем на их список и на их краткие описания.

## 21 Bash-команда

  

### ▍Получение информации

  

-   `man`: выводит руководство пользователя (справку) по команде.
-   `pwd`: выводит сведения о рабочей директории.
-   `ls`: выводит содержимое директории.
-   `ps`: позволяет просматривать сведения о работающих процессах.

  

### ▍Манипуляции с файловой системой

  

-   `cd`: изменение рабочей директории.
-   `touch`: создание файла.
-   `mkdir`: создание директории.
-   `cp`: копирование файла.
-   `mv`: перемещение или удаление файла.
-   `ln`: создание ссылки.

  

### ▍Перенаправление ввода-вывода и конвейеры

  

-   `<`: перенаправление `stdin`.
-   `>`: перенаправление `stdout`.
-   `|`: перенаправление с помощью конвейера вывода одной команды на вход другой команды.

  

### ▍Чтение файлов

  

-   `head`: чтение начала файла.
-   `tail`: чтение конца файла.
-   `cat`: чтение файла и вывод его содержимого на экран или конкатенация файлов.

  

### ▍Удаление файлов, остановка процессов

  

-   `rm`: удаление файла.
-   `kill`: остановка процесса.

  

### ▍Поиск

  

-   `grep`: поиск информации.
-   `ag`: продвинутая команда для поиска.

  

### ▍Архивация

  

-   `tar`: создание архивов и работа с ними.

Поговорим об этих командах подробнее.

## Подробности о командах

Для начала давайте разберёмся с командами, результаты работы которых выдаются в форме `stdout`. Обычно эти результаты появляются в окне терминала.

### ▍Получение информации

`man command_name`: вывод руководства по команде, то есть — справочной информации.

`pwd`: вывод на экран пути к текущей рабочей директории. В ходе работы с командной строкой пользователю часто нужно узнавать то, где именно в системе он находится.

`ls`: вывод содержимого директории. Эта команда тоже используется весьма часто.

`ls -a`: вывод скрытых файлов. Здесь применён флаг `-a` команды `ls`. Использование флагов помогает настраивать поведение команд.

`ls -l`: вывод подробной информации о файлах.

Обратите внимание на то, что флаги можно комбинировать. Например — так: `ls -al`.

`ps`: просмотр выполняющихся процессов.

`ps -e`: вывод сведений обо всех выполняющихся процессах, а не только о тех, которые связаны с текущей оболочкой пользователя. Данную команду часто используют именно в таком виде.

### ▍Манипуляции с файловой системой

`cd my_directory`: изменение рабочей директории на `my_directory`. Для того чтобы перейти на один уровень выше в дереве каталогов используйте в качестве `my_directory` относительный путь `../`.

![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/6704fa9b298c593b69a5826f72042954.png)

_Команда cd_

`touch my_file`: создание файла `my_file` по заданному пути.

`mkdir my_directory`: создание папки `my_directory` по заданному пути.

`mv my_file target_directory`: перемещение файла `my_file` в папку `target_directory`. При указании целевой директории нужно использовать абсолютный путь к ней (а не конструкцию вроде `../`).

Команду `mv`, кроме того, можно использовать для переименования файлов или папок. Например, выглядеть это может так:

`mv my_old_file_name.jpg my_new_file_name.jpg   cp my_source_file target_directory`: создание копии файла `my_source_file` и помещение её в папку `target_directory`.

`ln -s my_source_file my_target_file`: создание символической ссылки `my_target_file` на файл `my_source_file`. Если изменить ссылку, то изменится и исходный файл.

Если файл `my_source_file` будет удалён, то `my_target_file` останется. Флаг `-s` команды `ln` позволяет создавать ссылки и для директорий.

Теперь поговорим о перенаправлении ввода-вывода и конвейерах.

### ▍Перенаправление ввода-вывода и конвейеры

`my_command < my_file`: заменяет дескриптор файла стандартного ввода (`stdin`) на файл `my_file`. Это может оказаться полезным в том случае, если команда ожидает ввода неких данных с клавиатуры, а эти данные заранее сохранены в файле.

`my_command > my_file`: перенаправляет результаты работы команды, то есть то, что обычно попадает в `stdout` и выводится на экран, в файл `my_file`. Если файл `my_file` не существует — он создаётся. Если файл существует — он перезаписывается.

Например, после выполнения команды `ls > my_folder_contents.txt` будет создан текстовый файл, содержащий список того, что находится в текущей рабочей директории.

Если вместо символа `>` воспользоваться конструкцией `>>`, то, при условии существования файла, в который перенаправляется вывод команды, этот файл перезаписан не будет. Данные будут добавлены в конец этого файла.

Теперь взглянем на конвейерную обработку данных.

![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/4204454c659bababa2571cde03dc75b8.jpg)

_То, что выводит одна команда, подаётся на вход другой команды. Это похоже на подключение одной трубы к другой_

`first_command | second_command`: символ конвейера, `|`, используется для того чтобы отправить результаты работы одной команды другой команде. То, что команда, находящаяся в левой части описываемой конструкции, отправляет в `stdout`, попадает в `stdin` команды, которая находится справа от символа конвейера.

В Linux конвейерную обработку данных можно организовать с использованием практически любой правильно составленной команды. Часто говорят, что всё в Linux — это конвейер.

С помощью символа конвейера можно объединять в цепочку несколько команд. Выглядит это так:

```
first_command | second_command | third_command
```

![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/c9638a5d0734b168240e1fedde5c131e.jpg)

_Конвейер из нескольких команд можно сравнить с трубопроводом_

Обратите внимание на то, что когда команда, находящаяся слева от символа `|`, выводит что-то в `stdout`, то, что она вывела, немедленно становится доступным в виде `stdin` второй команде. То есть оказывается, что, используя конвейер, мы имеем дело с параллельным выполнением команд. Иногда это может привести к неожиданным результатам. Подробности об этом можно почитать [здесь](https://stackoverflow.com/a/9834118/4590385).

Теперь поговорим о чтении данных из файлов и о выводе их на экран.

### ▍Чтение файлов

`head my_file`: считывает строки из начала файла и выводит их на экран. Читать можно не только содержимое файлов, но и то, что команды выводят в `stdin`, используя эту команду в качестве элемента конвейера.

`tail my_file`: считывает строки из конца файла. Эту команду тоже можно использовать в конвейере.

![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/543f4e05d7559b6a392e375c96df4675.jpg)

_Head (голова) находится спереди, а tail (хвост) — сзади_

Если вы работаете с данными, используя библиотеку pandas, тогда команды `head` и `tail` должны быть вам знакомы. Если это не так — взгляните на вышеприведённый рисунок, и вы без труда их запомните.

Рассмотрим другие способы чтения файлов, поговорим о команде `cat`.

Команда `cat` либо выводит содержимое файла на экран, либо конкатенирует несколько файлов. Это зависит от того, сколько файлов передано этой команде при вызове.

![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/76873eabd0fd4fc321ba8a70d580c2e4.jpg)

_Команда cat_

`cat my_one_file.txt`: когда этой команде передают один файл — она выводит его в `stdout`.

Если же передать ей два файла или большее количество файлов, то она ведёт себя по-другому.

`cat my_file1.txt my_file2.txt`: получив на вход несколько файлов эта команда конкатенирует их содержимое и выведет то, что получилось в `stdout`.

Если результат конкатенации файлов нужно сохранить в виде нового файла, можно воспользоваться оператором `>`:

```
cat my_file1.txt my_file2.txt &gt; my_new_file.txt
```

Теперь поговорим о том, как удалять файлы и останавливать процессы.

### ▍Удаление файлов, остановка процессов

`rm my_file`: удаляет файл `my_file`.

`rm -r my_folder`: удаляет папку `my_folder` и все содержащиеся в ней файлы и папки. Флаг `-r` указывает на то, что команда будет работать в рекурсивном режиме.

Для того чтобы система не запрашивала подтверждение при выполнении каждой операции удаления файла или папки, воспользуйтесь флагом `-f`.

`kill 012345`: останавливает указанный выполняющийся процесс, давая ему время на корректное завершение работы.

`kill -9 012345`: принудительно завершает указанный запущенный процесс. Флаг вида `-s SIGKILL` означает то же самое, что и флаг `-9`.

### ▍Поиск

Для поиска данных можно использовать разные команды. В частности — `grep`, `ag` и `ack`. Начнём наше знакомство с этими командами с `grep`. Это — проверенная временем, надёжная команда, которая, правда, медленнее других и не так, как они, удобна в использовании.

![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/e504f5fbf1cdfe2c5b270449c3e54a62.jpg)

_Команда grep_

`grep my_regex my_file`: выполняет поиск `my_regex` в `my_file`. При обнаружении совпадений возвращается, для каждого из них, вся строка. По умолчанию `my_regex` воспринимается как регулярное выражение.

`grep -i my_regex my_file`: поиск выполняется без учёта регистра символов.

`grep -v my_regex my_file`: возвращает все строки, в которых не содержится `my_regex`. Флаг `-v` означает инверсию, он напоминает оператор `NOT`, имеющийся во многих языках программирования.

`grep -c my_regex my_file`: возвращает сведения о количестве совпадений с искомым шаблоном, найденных в файле.

`grep -R my_regex my_folder`: выполняет рекурсивный поиск во всех файлах, находящихся в заданной папке и в папках, вложенных в неё.

Теперь поговорим о команде `ag`. Она появилась позже `grep`, она быстрее, работать с ней удобнее.

![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/3c2ab0e18393d78d2453c4f55eb09c78.jpg)

_Команда ag_

`ag my_regex my_file`: возвращает сведения о номерах строк, и сами строки, в которых найдены совпадения с `my_regex`.

`ag -i my_regex my_file`: поиск выполняется без учёта регистра символов.

Команда `ag` автоматически обрабатывает файл `.gitignore` и исключает из вывода то, что найдено в папках или файлах, перечисленных в этом файле. Это очень удобно.

`ag my_regex my_file -- skip-vcs-ignores`: содержимое файлов систем автоматического контроля версий (наподобие `.gitignore`) при поиске не учитывается.

Кроме того, для того чтобы указать команде `ag` на то, какие пути к файлам нужно исключить из поиска, можно создать файл `.agignore`.

В начале этого раздела мы упомянули о команде `ack`. Команды `ack` и `ag` очень похожи, можно сказать, что они взаимозаменяемы на 99%. Однако команда `ag` работает быстрее, поэтому я описал именно её.

Теперь поговорим о работе с архивами.

### ▍Архивация

`tar my_source_directory`: объединяет файлы из папки `my_source_directory` в один файл tarball. Такие файлы удобно использовать для того, чтобы передавать кому-нибудь большие наборы файлов.

![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/9fd5476a9c0109ff8ae609909ed4f952.jpg)

_Команда tar_

Tarball-файлы, создаваемые этой командой, представляют собой файлы с расширением `.tar` (Tape ARchive). То, что в названии команды и в расширении имён файлов, создаваемых ей, скрыто слово «tape» (лента), говорит о том, как давно существует эта команда.

`tar -cf my_file.tar my_source_directory`: создаёт tarball-файл с именем `my_file.tar` с содержимым папки `my_source_directory`. Флаг `-c` расшифровывается как «create» (создание), а флаг `-f` как «file» (файл).

Для извлечения файлов, находящихся в `.tar`\-файле, используется команда `tar` c флагами `-x` («extract», извлечение) и `-f` («file», файл).

`tar -xf my_file.tar`: извлекает файлы из `my_file.tar` в текущую рабочую директорию.

Теперь поговорим о том, как сжимать и распаковывать `.tar`\-файлы.

`tar -cfz my_file.tar.gz my_source_directory`: здесь, с использованием флага `-z` («zip», алгоритм сжатия) указано, что для сжатия файлов должен использоваться алгоритм `gzip` (GNU zip). Сжатие файлов позволяет экономить дисковое пространство при хранении таких файлов. Если же файлы планируется, например, передавать другим пользователям, это способствует более быстрой загрузке таких файлов.

Распаковать файл `.tar.gz` можно, добавив флаг `-z` к команде извлечения содержимого `.tar`\-файлов, которую мы рассматривали выше. Выглядит это так:

`tar -xfz my_file.tar.gz`  
Надо отметить, что у команды `tar` есть ещё множество полезных флагов.

## Bash-псевдонимы

Bash-псевдонимы (их ещё называют алиасами или сокращениями) предназначены для создания сокращённых наименований команд или их последовательностей, использование которых вместо обычных команд ускоряет работу. Если у вас, предположим, имеется псевдоним `bu`, за которым скрывается команда `python setup.py sdist bdist_wheel`, то для вызова данной команды достаточно воспользоваться этим псевдонимом.

Для создания подобного псевдонима достаточно добавить следующую команду в файл `~/.bash_profile`:

```
alias bu="python setup.py sdist bdist_wheel"
```

Если в вашей системе нет файла `~/.bash_profile`, то вы можете создать его самостоятельно, воспользовавшись командой `touch`. После создания псевдонима перезапустите терминал, после чего вы сможете этим псевдонимом пользоваться. В данном случае ввод двух символов заменяет ввод более чем трёх десятков символов команды, которая предназначена для [сборки](https://towardsdatascience.com/build-your-first-open-source-python-project-53471c9942a7?source=friends_link&sk=576540dbd90cf2ee72a3a0e0bfa72ffb) Python-пакетов.

В `~/.bash_profile` можно добавлять псевдонимы для любых часто используемых команд.

### ▍Итоги

В этом материале мы рассмотрели 21 популярную команду Bash и поговорили о создании псевдонимов для команд. Если вам эта тема интересна — [вот](https://habr.com/ru/company/ruvds/blog/325522/) цикл публикаций, посвящённый Bash. [Здесь](https://habr.com/ru/company/ruvds/blog/336764/) можно найти pdf-версию этих публикаций. Кроме того, если вы хотите освоить Bash, помните о том, что тут, как и при изучении любой другой программной системы, важна практика.

**Уважаемые читатели!** Какие команды, которые полезно знать начинающим, вы добавили бы к тем, которые были рассмотрены в этой статье?

→ [Также читайте в нашем блоге цикл публикаций про bash-скрипты](https://habr.com/ru/company/ruvds/blog/325522/)

[![](%D0%B2%20%D0%B7%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8%20Bash%20%D0%B4%D0%BB%D1%8F%20%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85%2021%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0%20%20%D0%A5%D0%B0%D0%B1%D1%80/1ba550d25e8846ce8805de564da6aa63.png)](https://ruvds.com/ru-rub/#order)
