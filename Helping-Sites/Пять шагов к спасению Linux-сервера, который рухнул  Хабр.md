---
created: 2024-02-27T10:14:08 (UTC +06:00)
tags: [Linux,администрирование,диагностика]
source: https://habr.com/ru/companies/ruvds/articles/330350/
author: ru_vds
---

# Пять шагов к спасению Linux-сервера, который рухнул / Хабр

> ## Excerpt
> Мне доводилось видеть множество Linux-серверов, которые, без единой перезагрузки, работали годами, в режиме 24x7. Но ни один компьютер не застрахован от неожидан...

---
Мне доводилось видеть множество Linux-серверов, которые, без единой перезагрузки, работали годами, в режиме 24x7. Но ни один компьютер не застрахован от неожиданностей, к которым могут вести «железные», программные и сетевые сбои. Даже самый надёжный сервер может однажды отказать. Что делать? Сегодня вы узнаете о том, что стоит предпринять в первую очередь для того, чтобы выяснить причину проблемы и вернуть машину в строй.

[

![image](%D0%9F%D1%8F%D1%82%D1%8C%20%D1%88%D0%B0%D0%B3%D0%BE%D0%B2%20%D0%BA%20%D1%81%D0%BF%D0%B0%D1%81%D0%B5%D0%BD%D0%B8%D1%8E%20Linux-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0,%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9%20%D1%80%D1%83%D1%85%D0%BD%D1%83%D0%BB%20%20%D0%A5%D0%B0%D0%B1%D1%80/61d64686f2f62167fc6a5ef45dbfd235.jpg)

](https://habrahabr.ru/company/ruvds/blog/330350/)

И, кстати, в самом начале, сразу после сбоя, стоит ответить на весьма важный вопрос: «А сервер ли виноват в том, что случилось?». Вполне возможно, что источник проблемы совсем не в нём. Но, не будем забегать вперёд.  

## Поиск и устранение неполадок: раньше и теперь

Когда, в 1980-х, я начал работать системным администратором Unix — задолго до того, как Линус Торвальдс загорелся идеей Linux — если с сервером было что-то не так, это была реальная засада. Тогда было сравнительно мало инструментов для поиска проблем, поэтому для того, чтобы сбойный сервер снова заработал, могло понадобиться много времени.

Теперь всё совсем не так, как раньше. Как-то один системный администратор вполне серьёзно сказал мне, говоря о проблемном сервере: «Я его уничтожил и поднял новый».

В былые времена такое звучало бы дико, но сегодня, когда ИТ-инфраструктуры строят на основе виртуальных машин и контейнеров… В конце концов, развёртывание новых серверов по мере необходимости — это обычное дело в любой облачной среде.

Сюда надо добавить инструменты [DevOps](https://insights.hpe.com/articles/why-cloud-makes-agile-and-devops-more-important-1701.html), такие, как [Chef](https://insights.hpe.com/articles/what-is-chef-a-primer-for-devops-newbies-1704.html) и [Puppet](https://insights.hpe.com/articles/what-is-puppet-and-why-should-you-consider-it-for-your-cloud-and-servers-1705.html), используя которые [легче создать новый сервер](http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/), чем диагностировать и «чинить» старый. А если говорить о таких [высокоуровневых средствах](https://insights.hpe.com/articles/the-basics-explaining-kubernetes-mesosphere-and-docker-swarm-1702.html), как Docker Swarm, Mesosphere и Kubernetes, то благодаря им работоспособность отказавшего сервера будет автоматически восстановлена до того, как администратор узнает о проблеме.

Данная концепция стала настолько распространённой, что ей дали название — [бессерверные вычисления](https://techbeacon.com/aws-lambda-serverless-apps-5-things-you-need-know-about-serverless-computing). Среди платформ, которые предоставляют подобные возможности — [AWS Lambda](http://aws.amazon.com/lambda/), [Iron.io](https://www.iron.io/platform/), [Google Cloud Functions](https://cloud.google.com/functions/docs/).

Благодаря такому подходу облачный сервис отвечает за администрирование серверов, решает вопросы масштабирования и массу других задач для того, чтобы предоставить клиенту вычислительные мощности, необходимые для запуска его приложений.

Бессерверные вычисления, виртуальные машины, контейнеры — все эти уровни абстракции скрывают реальные серверы от пользователей, и, в некоторой степени, от системных администраторов. Однако, в основе всего этого — физическое аппаратное обеспечение и операционные системы. И, если что-то на данном уровне вдруг разладится, кто-то должен привести всё в порядок. Именно поэтому то, о чём мы сегодня говорим, никогда не потеряет актуальности.

Помню разговор с одним системным оператором. Вот что он говорил о том, как надо поступать после сбоя: «Переустановка сервера — это путь вникуда. Так не понять — что стало с машиной, и как не допустить такого в будущем. Ни один сносный администратор так не поступает». Я с этим согласен. До тех пор, пока не обнаружен первоисточник проблемы, её нельзя считать решённой.

Итак, перед нами сервер, который дал сбой, или мы, по крайней мере, подозреваем, что источник неприятностей именно в нём. Предлагаю вместе пройти пять шагов, с которых стоит начинать поиск и решение проблем.

## Шаг первый. Проверка аппаратного обеспечения

В первую очередь — проверьте железо. Я знаю, что звучит это тривиально и несовременно, но, всё равно — сделайте это. Встаньте с кресла, подойдите к серверной стойке и удостоверьтесь в том, что сервер правильно подключён ко всему, необходимому для его нормальной работы.

Я и сосчитать не смогу, сколько раз поиски причины проблемы приводили к кабельным соединениям. Один взгляд на светодиоды — и становится ясно, что Ethernet-кабель выдернут, или питание сервера отключено.

Конечно, если всё выглядит более-менее прилично, можно обойтись без визита к серверу и проверить состояние Ethernet-соединения такой командой:

```
$ sudo ethtool eth0
```

Если её ответ можно трактовать, как «да», это значит, что исследуемый интерфейс способен обмениваться данными по сети.

Однако, не пренебрегайте возможностью лично осмотреть устройство. Это поможет, например, узнать, что кто-то выдернул какой-нибудь важный кабель и обесточил таким образом сервер или всю стойку. Да, это до смешного просто, но удивительно — как часто причина отказа системы именно в этом.

Ещё одну распространённую аппаратную проблему невооружённым взглядом не распознать. Так, сбойная память является причиной всевозможных проблем.

Виртуальные машины и контейнеры могут скрывать эти проблемы, но если вы столкнулись с закономерным появлением отказов, связанных с конкретным [физическим выделенным сервером](http://www.internap.com/2015/02/26/bare-metal-vs-hypervisor/), проверьте его память.

Для того, чтобы увидеть, что BIOS/UEFI сообщают об аппаратном обеспечении компьютера, включая память, используйте команду [dmidecode](https://www.howtoforge.com/dmidecode-finding-out-hardware-details-without-opening-the-computer-case):

```
$ sudo dmidecode --type memory
```

Даже если всё тут выглядит нормально, на самом деле это может быть и не так. Дело в том, что данные SMBIOS не всегда точны. Поэтому, если после `dmidecode` память всё ещё остаётся под подозрением — пришло время воспользоваться [Memtest86](http://www.memtest.org/). Это отличная программа для проверки памяти, но работает она медленно. Если вы запустите её на сервере, не рассчитывайте на возможность использовать эту машину для чего-нибудь другого до завершения проверки.

Если вы сталкиваетесь со множеством проблем с памятью — я видел такое в местах, отличающихся нестабильным электропитанием — нужно загрузить модуль ядра Linux [edac\_core](http://buttersideup.com/edacwiki/Main_Page). Этот модуль постоянно проверяет память в поиске [сбойных участков](http://fibrevillage.com/sysadmin/240-how-to-identify-defective-dimm-from-edac-error-on-linux-2). Для того, чтобы загрузить этот модуль, воспользуйтесь такой командой:

```
$ sudo modprobe edac_core
```

Подождите какое-то время и посмотрите, удастся ли что-нибудь увидеть, выполнив такую команду:

```
$ sudo grep "[0-9]" /sys/devices/system/edac/mc/mc*/csrow*/ch*_ce_count
```

Эта команда даст вам сводку о числе ошибок, разбитых по модулям памяти (показатели, название которых начинается с `csrow`). Эти сведения, если сопоставить их с с данными `dmidecode` о каналах памяти, слотах и заводских номерах компонентов, помогут выявить сбойную планку памяти.

## Шаг второй. Поиск истинного источника проблемы

Итак, сервер стал странно себя вести, но дым из него ещё пока не идёт. В сервере ли дело? Прежде чем вы попытаетесь решить возникшую проблему, сначала нужно точно определить её источник. Скажем, если пользователи жалуются на странности с серверным приложением, сначала проверьте, что причина проблемы — не в сбоях на клиенте.

Например, друг однажды рассказал мне, как его пользователи сообщили о том, что не могут работать с IBM Tivoli Storage Manager. Сначала, конечно, казалось, что виновен во всём сервер. Но в итоге администратор выяснил, что проблема вообще не была связана с серверной частью. Причиной был неудачный патч Windows-клиента [3076895](https://support.microsoft.com/en-us/help/3092627/september-2015-update-to-fix-windows-or-application-freezes-after-you-install-security-update-3076895). Но то, как сбоило это обновление безопасности, делало происходящее похожим на проблему серверной стороны.

Кроме того, нужно понять, является ли причиной проблемы сам сервер, или серверное приложение. Например, серверная программа может работать кое как, а железо оказывается в полном порядке.

Для начала — самое очевидное. Работает ли приложение? Есть множество способов проверить это. Вот два моих любимых:

```
$ sudo ps -ef | grep apache2
$ sudo netstat -plunt | grep apache2
```

Если оказалось, что, например, веб-сервер Apache не работает, запустить его можно такой командой:

```
$ sudo service apache2 start
```

Если в двух словах, то прежде чем диагностировать сервер и искать причину проблему, узнайте — сервер ли виноват, или что-то другое. Только тогда, когда вы поймёте, где именно находится источник сбоя, вы сможете задавать правильные вопросы и переходить к дальнейшему анализу того, что произошло.

Это можно сравнить с неожиданной остановкой автомобиля. Вы знаете, что машина дальше не едет, но, прежде чем тащить её в сервис, хорошо бы проверить, есть ли бензин в баке.

## Шаг третий. Использование команды top

Итак, если оказалось, что все пути ведут к серверу, то вот ещё один важный инструмент для проверки системы — команда `top`. Она позволяет узнать среднюю нагрузку на сервер, использование файла подкачки, выяснить, какие ресурсы системы используют процессы. Эта утилита показывает общие сведения о системе и выводит данные по всем выполняющимся процессам на Linux-сервере. [Вот](http://rus-linux.net/MyLDP/consol/komanda-top-v-linux.html) подробное описание данных, которые выводит эта команда. Тут можно найти массу информации, которая способна помочь в поиске проблем с сервером. Вот несколько полезных способов работы с `top`, позволяющих найти проблемные места.

Для того, чтобы обнаружить процесс, потребляющий больше всего памяти, список процессов надо отсортировать в интерактивном режиме, введя с клавиатуры `M`. Для того, чтобы выяснить приложение, потребляющее больше всего ресурсов процессора, отсортируйте список, введя `P`. Для сортировки процессов по времени активности, введите с клавиатуры `T`. Для того, чтобы лучше видеть колонку, по которой производится сортировка, нажмите клавишу `b`.

Кроме того, данные по процессам, выводимые командой в интерактивном режиме, можно отфильтровать, введя `O` или `o`. Появится следующее приглашение, где предлагается добавить фильтр:

```
add filter #1 (ignoring case) as: [!]FLD?VAL
```

Затем можно ввести шаблон, скажем, для фильтрации по конкретному процессу. Например, благодаря фильтру `COMMAND=apache`, программа будет выводить только сведения о процессах Apache.

Ещё одна полезная возможность `top` заключается в выводе полного пути процесса и аргументов запуска. Для того, чтобы просмотреть эти данные, воспользуйтесь клавишей `c`.

Ещё одна похожая возможность `top` активируется вводом символа `V`. Она позволяет переключиться в режим иерархического вывода сведений о процессах.

Кроме того, можно просматривать процессы конкретного пользователя с помощью клавиш `u` или `U`, или скрыть процессы, не потребляющих ресурсы процессора, нажав клавишу `i`.

Хотя `top` долго была самой популярной интерактивной утилитой Linux для просмотра текущей ситуации в системе, у неё есть и альтернативы. Например, существует программа [htop](http://hisham.hm/htop/) обладает расширенным набором возможностей, которая отличается более простым и удобным графическим интерфейсом [Ncurses](https://www.gnu.org/software/ncurses/). Работая с `htop`, можно пользоваться мышью и прокручивать список процессов по вертикали и по горизонтали для того, чтобы просмотреть их полный список и полные командные строки.

Я не жду, что `top` сообщит мне — в чём проблема. Скорее, я использую этот инструмент для того, чтобы найти нечто, что заставит подумать: «А это уже интересно», и вдохновит меня на дальнейшие исследования. Основываясь на данных от `top`, я знаю, например, на какие логи стоит взглянуть в первую очередь. Логи я просматриваю, используя комбинации команд `less`, `grep` и `tail -f`.

## Шаг четвёртый. Проверка дискового пространства

Даже сегодня, когда в кармане можно носить терабайты информации, на сервере, совершенно незаметно, может кончиться дисковое пространство. Когда такое происходит — можно увидеть весьма странные вещи.

Разобраться с дисковым пространством нам поможет старая добрая команда [df](http://www.linuxjournal.com/article/2747), имя которой является сокращением от «disk filesystem». С её помощью можно получить сводку по свободному и использованному месту на диске.

Обычно `df` используют двумя способами.

-   ```
    $ sudo df -h
    ```
    
      
    показывает данные о жёстких дисках в удобном для восприятия виде. Например, сведения об объёме накопителя выводятся в гигабайтах, а не в виде точного количества байт.
-   ```
    $ sudo df -i
    ```
    
      
    выводит число использованных [inodes](http://www.grymoire.com/Unix/Inodes.html) и их процент к файловой системе.  
    

Ещё один полезный флаг `df — T`. Он позволяет вывести данные о типах файловых систем хранилищ. Например, команда вида `$ sudo df -hT` показывает и объём занятого пространства диска, и данные о его файловой системе.

Если что-то кажется вам странным, можно копнуть глубже, воспользовавшись командой [Iostat](https://linux.die.net/man/1/iostat). Она является частью [sysstat](http://sebastien.godard.pagesperso-orange.fr/) — продвинутого набора инструментов для мониторинга системы. Она выводит сведения о процессоре, а также данные о подсистеме ввода-вывода для блочных устройств хранения данных, для разделов и сетевых файловых систем.

Вероятно, самый полезный способ вызова этой команды выглядит так:

```
$ iostat -xz 1
```

Такая команда выводит сведения об объёме прочитанных и записанных данных для устройства. Кроме того, она покажет среднее время операций ввода-вывода в миллисекундах. Чем больше это значение — тем вероятнее то, что накопитель перегружен запросами, или перед нами — аппаратная проблема. Что именно? Тут можно воспользоваться утилитой `top` для того, чтобы выяснить, нагружает ли сервер MySQL (или какая-нибудь ещё работающая на нём СУБД). Если подобных приложений найти не удалось, значит есть вероятность, что с диском что-то не так.

Ещё один важный показатель можно найти в разделе `%util`, где выводятся сведения об использовании устройства. Этот показатель указывает на то, как напряжённо работает устройство. Значения, превышающие 60% указывают на низкую производительность дисковой подсистемы. Если значение близко к 100%, это означает, что диск работает на пределе возможностей.

Работая с утилитами для проверки дисков, обращайте внимание, что именно вы анализируете.

Например, нагрузка в 100% на логический диск, который представляет собой несколько физических дисков, может означать лишь то, что система постоянно обрабатывает какие-то операции ввода-вывода. Значение имеет то, что именно происходит на физических дисках. Поэтому, если вы анализируете логический диск, помните, что дисковые утилиты не дадут полезной информации.

## Шаг пятый. Проверка логов

Последнее в нашем списке, но лишь по порядку, а не по важности — проверка логов. Обычно их можно найти по адресу `/var/log`, в отдельных папках для различных сервисов.

Для новичков в Linux лог-файлы могут выглядеть как ужасная мешанина. Это — текстовые файлы, в которые записываются сведения о том, чем занимаются операционная система и приложения. Есть два вида записей. Одни записи — это то, что происходит в системе или в программе, например — каждая транзакция или перемещение данных. Вторые — сообщения об ошибках. В лог-файлах может содержаться и то, и другое. Эти файлы могут быть просто огромными.

Данные в файлах журналов обычно выглядят довольно таинственно, но вам всё равно придётся с ними разобраться. [Вот](https://www.digitalocean.com/community/tutorials/how-to-view-and-configure-linux-logs-on-ubuntu-and-centos), например, хорошее введение в эту тему от Digital Ocean.

Есть множество инструментов, которые помогут вам проверить логи. Например — [dmesg](http://www.linfo.org/dmesg.html). Эта утилита выводит сообщения ядра. Обычно их очень и очень много, поэтому используйте следующий простой сценарий командной строки для того, чтобы просмотреть 10 последних записей:

```
$ dmesg | tail
```

Хотите следить за происходящим в реальном времени? Мне, определённо, это нужно, когда я занимаюсь поиском проблем. Для того, чтобы этого добиться, используйте команду `tail` с ключом `-f`. Выглядит это так:

```
$ dmesg | tail -f /var/log/syslog
```

Вышеприведённая команда наблюдает за файлом `syslog`, и когда в него попадают сведения о новых событиях, выводит их на экран.

Вот ещё один удобный сценарий командной строки:

```
$ sudo find /var/log -type f -mtime -1 -exec tail -Fn0 {} +
```

Он сканирует логи и показывает возможные проблемы.

Если в вашей системе применяется [systemd](https://www.freedesktop.org/wiki/Software/systemd/) то, вам нужно будет использовать встроенное средство для работы с журналами — [Journalctl](https://www.freedesktop.org/software/systemd/man/journalctl.html). Systemd централизует управление логированием с помощью демона `journald`. В отличие от других логов Linux, `journald` хранит данные в двоичном, а не в текстовом формате.

Бывает полезно настроить `journald` так, чтобы он сохранял логи после перезагрузки системы. Сделать это можно, воспользовавшись такой командой:

```
$ sudo mkdir -p /var/log/journal
```

Для включения постоянного хранения записей понадобится отредактировать файл `/etc/systemd/journald.conf`, включив в него следующее:

```
[Journal] Storage=persistent
```

Самый распространённый способ работать с этими журналами — такая команда:

```
journalctl -b
```

Она покажет все записи журналов после последней перезагрузки. Если система была перезагружена, посмотреть, что было до этого, можно с помощью такой команды:

```
$ journalctl -b -1
```

Это позволит просмотреть записи журналов, сделанные в предыдущую сессию сервера.  
[Вот](https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs) полезный материал о том, как пользоваться `journalctl`.

Логи бывают очень большими, с ними сложно работать. Поэтому, хотя разобраться с ними можно с помощью средств командной строки, таких, как `grep`, `awk`, и других, полезно бывает задействовать специальные программы для просмотра логов.

Мне, например, нравится система для управления логами с открытым кодом [Graylog](https://www.graylog.org/). Она собирает, индексирует и анализирует самые разные сведения. В её основе лежат [MongoDB](https://www.mongodb.com/) для работы с данными и [Elasticsearch](https://www.elastic.co/) для поиска по лог-файлам. Graylog упрощает отслеживание состояния сервера. Graylog, если сравнить её со встроенными средствами Linux, проще и удобнее. Кроме того, среди её полезных возможностей можно отметить возможность работы с многими DevOps-системами, такими, как Chef, Puppet и [Ansible](https://www.ansible.com/).

## Итоги

Как бы вы ни относились к вашему серверу, возможно, он не попадёт в Книгу Рекордов Гиннеса как тот, который проработал дольше всех. Но стремление сделать сервер как можно более стабильным, добираясь до сути неполадок и исправляя их — достойная цель. Надеемся, то, о чём мы сегодня рассказали, поможет вам достичь этой цели.

Уважаемые читатели! А как вы обычно поступаете с упавшими серверами?
