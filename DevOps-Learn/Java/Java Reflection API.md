Содержание

1. 1. [Возможности](https://blog.skillfactory.ru/glossary/java-reflection-api/#возможности)
2. 2. [Особенности рефлексии в Java](https://blog.skillfactory.ru/glossary/java-reflection-api/#особенности-рефлексии-в-java)
3. 3. [Пример работы Reflection API в Java](https://blog.skillfactory.ru/glossary/java-reflection-api/#пример-работы-reflection-api-в-java)

Java Reflection API — это программный интерфейс в языке Java, который позволяет приложениям анализировать свои компоненты и программное окружение, изменять собственное поведение и структуру. Позволяет исследовать информацию о полях, методах и конструкторах классов.

С помощью механизма рефлексии можно обрабатывать типы, которые отсутствовали при компиляции, но появились во время выполнения программы. Рефлексия и наличие логически целостной модели выдачи информации об ошибках позволяют создавать корректный динамический код. 

## Возможности

Помимо самомодификации, API способен проводить самопроверку и самоклонирование. Чаще всего рефлексию Java используют:

- для получения информации о классах, интерфейсах, функциях, конструкторах, методах и модулях;
- изменения имен функций и классов во время выполнения программы;
- создания новых экземпляров классов;
- анализа и исполнения кода, поступающего из программного окружения;
- преобразования классов из одного типа в другой;
- создания массивов данных и манипуляций с ними;
- установления значений полей объектов по именам;
- получения доступа к переменным и методам, включая приватные, и к внешним классам;
- вызова методов объектов по именам.

![[c940c6cf1ceb1e8e23e11a8bc0f632ed_MD5.png]]

Схема работы Reflection API

## Особенности рефлексии в Java

### Снижение производительности программы

Рефлексия работает медленнее, чем обычные приемы по обработке классов, методов и переменных. Это связано с тем, что во время динамического определения многих типов оптимизация производительности становится недоступной. Поэтому не следует применять Reflection API во фрагментах кода, которые часто используются приложением, в особенности если скорость выполнения программы — приоритет разработчика.

### Блокировка диспетчером безопасности

Для запуска рефлексии в программировании требуется разрешение на выполнение, которое, как правило, не выдается при работе программного компонента под управлением Security Manager (диспетчера безопасности).

### Уязвимость

При неверном использовании API способен нарушать один из главных принципов объектно-ориентированного программирования — инкапсуляцию данных. Это может привести к появлению потенциальных уязвимостей в веб-приложениях. В период с 2013 по 2016 год в библиотеке Reflection [существовала брешь](https://www.infoq.com/news/2016/04/java-reflection-vulnerability/), которая позволяла хакерам обходить «песочницу» (изолированную зону для выполнения программ).

### Нарушение переносимости программы

Поскольку Reflection API позволяет коду выполнять операции, которые обычно находятся под запретом, например получать доступ к закрытым полям и методам, использование рефлексии может сделать код неработоспособным и нарушить переносимость с одной операционной системы на другую. ==Кроме того, рефлексивный код нарушает абстракции, поэтому может изменить поведение программы при обновлении платформы.==

## Пример работы Reflection API в Java

Чтобы использовать Java Reflection API, не нужно подключать сторонние библиотеки. Все расположено в пакете [java.lang.reflect](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html).

Продемонстрируем некоторые методы рефлексии в программировании на конкретных примерах.

// Демонстрация работы Рефлексии в Java

_import java.lang.reflect.Method;  
import java.lang.reflect.Field;  
import java.lang.reflect.Constructor;_

// Создание объектов для класса Sample

_class Sample  
{_

// Создаем приватное поле private

_String s;_

// Создаем публичный конструктор

_public Sample() { s = «Java Reflection API»; }_

// Создаем публичный метод без параметров

_public void method1() {  
System.out.println(«Информация в строке — » + s); }_

// Создаем публичный метод с целым числом в качестве параметра

_public void method2(int x) {  
System.out.println(«Целое число — » + x);_  
_}_

// Создаем приватный метод

_private void method3() {  
System.out.println(«Вызов приватного метода»);  
}  
}  
class Exercise_

_{_  
_public static void main(String args[]) throws Exception_  
_{_

// Создаем объект для последующей проверки свойств

_Sample obj = new Sample();_

// Создаем новый объект класса из другого объекта

_Class cls = obj.getClass();  
System.out.println(«Имя класса — » +  
cls.getName());_

// Получаем имя конструктора класса с помощью объекта

_Constructor constructor = cls.getConstructor();  
System.out.println(«Имя конструктора — » +  
constructor.getName());  
System.out.println(«Это публичные методы классов: «);_

// Получаем методы классов с помощью объектов

_Method[] methods = cls.getMethods();_

// Выводим имена методов

_for (Method method:methods)_  
_System.out.println(method.getName());_

// Создаем объект нужного метода с помощью имени метода и параметра класса

_Method methodcall1 = cls.getDeclaredMethod(«method2», int.class);_

// Вызов метода во время исполнения

_methodcall1.invoke(obj, 25);_

// Создаем объект нужного поля с помощью имени поля

_Field field = cls.getDeclaredField(«s»);_

// Открываем доступ к полю независимо от используемого в нем спецификатора доступа

_field.setAccessible(true);_

// Устанавливаем новое значение поля

_field.set(obj, «SkillFactory»);_

// Создаем объект метода с помощью имени метода

_Method methodcall2 = cls.getDeclaredMethod(«method1»);_

// Вызов метода во время исполнения

_methodcall2.invoke(obj);_

// Создаем третий объект метода с помощью имени метода

_Method methodcall3 = cls.getDeclaredMethod(«method3»);_

// Изменяем настройки доступа

_methodcall3.setAccessible(true);_

// Вызов метода во время исполнения

_methodcall3.invoke(obj);  
}  
}_

Рефлексия — мощный инструмент, для правильного использования которого требуются высокая квалификация и взвешенный подход.