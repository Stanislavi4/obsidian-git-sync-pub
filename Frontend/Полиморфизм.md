Содержание

1. 1. [Для чего нужен полиморфизм](https://blog.skillfactory.ru/glossary/polimorfizm/#для-чего-нужен-полиморфизм) 
2. 2. [Полиморфизм как принцип ООП](https://blog.skillfactory.ru/glossary/polimorfizm/#полиморфизм-как-принцип-ооп)
3. 3. [Что такое полиморфный метод и как его создают](https://blog.skillfactory.ru/glossary/polimorfizm/#что-такое-полиморфный-метод-и-как-его-создают)
4. 4. [Формы полиморфизма](https://blog.skillfactory.ru/glossary/polimorfizm/#формы-полиморфизма)
5. 5. [Статический и динамический полиморфизм](https://blog.skillfactory.ru/glossary/polimorfizm/#статический-и-динамический-полиморфизм)
6. 6. [Преимущества полиморфизма](https://blog.skillfactory.ru/glossary/polimorfizm/#преимущества-полиморфизма)
7. 7. [Недостатки полиморфизма](https://blog.skillfactory.ru/glossary/polimorfizm/#недостатки-полиморфизма)
8. 8. [Как начать изучать полиморфизм](https://blog.skillfactory.ru/glossary/polimorfizm/#как-начать-изучать-полиморфизм)

Полиморфизм (polymorphism) — это понятие из объектно-ориентированного программирования, которое позволяет разным сущностям выполнять одни и те же действия. При этом неважно, как эти сущности устроены внутри и чем они различаются.

С греческого языка слово «полиморфизм» означает «многообразие». Термин используют и в других сферах. Скажем, полиморфизм в биологии — способность какого-то вида существовать в разных формах. 

_Пример полиформности в природе — пчелы: есть рабочие пчелы, матка, трутни. Они разные, но все могут летать независимо от того, что это за пчела. По похожему принципу работает и полиморфизм в ООП._

Например, есть две разных сущности: картинка и видео. И тем, и другим можно поделиться: отправить в личное сообщение другому человеку. Программист может сделать два разных метода — один для картинки, другой для видео. А может воспользоваться полиморфизмом и создать один метод «Отправить» для обеих сущностей.

Такой метод будет называться полиморфным. Плюс этого подхода — разработчик пишет меньше кода и не повторяется.

Чтобы лучше понять, что такое полиморфизм и как он работает, советуем прочитать [статью про ООП](https://blog.skillfactory.ru/glossary/oop-obektno-orientirovannoe-programmirovanie/). Полиморфизм — один из четырех основных принципов этого способа программирования

## Для чего нужен полиморфизм 

- **Облегчает написание кода.** Не нужно придумывать десять разных методов: отправить одно, другое, третье. Есть один метод, который можно применять к разным сущностям и не задумываться.
- **Позволяет масштабировать решения.** Если понадобится отправлять не только видео и картинки, но и текст, это можно будет сделать той же командой.
- **Делает код более читаемым.** Разработчику не нужно разбираться, что делает десяток методов с похожими названиями. Есть один метод, и по его названию все понятно.
- **Помогает точно понимать, чего ждать от разных методов,** то есть делает код более предсказуемым. Не может быть такого, что метод «Отправить» вдруг окажется методом не для картинки, а для видео.

С понятием должен быть знаком любой разработчик. Множество языков программирования используют полиморфизм: [C](https://blog.skillfactory.ru/yazyk-c-s-chego-nachat/), [C++](https://blog.skillfactory.ru/cplus-komu-i-dlya-chego-nuzhen/), [Java](https://blog.skillfactory.ru/glossary/java/), [Python](https://blog.skillfactory.ru/glossary/python/) и другие. Не все эти языки чисто объектно-ориентированные: некоторые устроены так, что с ними можно работать в разных парадигмах программирования. Так что столкнуться с полиморфизмом может каждый.

## Полиморфизм как принцип ООП

В объектно-ориентированном программировании четыре основных принципа: инкапсуляция, абстракция, наследование и полиморфизм. Это связанные между собой вещи — без одного не работало бы и другое. 

**Инкапсуляция** — это создание сущностей как «вещей в себе». Классы должны работать независимо друг от друга: если какая-то сущность, например, удалится, это не повлияет на принцип работы остальных.

**Абстракция** — это принцип, когда какие-то общие вещи сводятся до набора абстрактных признаков. То есть мы имеем не абсолютно разные классы «картинка», «видео», «текст», а абстрактный класс «контент».

**Наследование** — это возможность делать на основе одних сущностей другие. Обычно в качестве «родителя» используются абстрактные сущности, а от них наследуются уже более конкретные. То есть если родитель — «контент», то дети — «картинка», «видео», «текст». Это все подвиды контента и его наследники.

Чтобы реализовать полиморфизм, нужны как минимум абстракция и наследование. Они помогают сделать абстрактный класс, в нем — абстрактный «общий» метод, а потом унаследовать разные реализации этого метода. В итоге название одно, а механика разная в зависимости от подтипа. Сейчас разберемся подробнее.

## Что такое полиморфный метод и как его создают

Полиформный — это многообразный: формы различаются, а действие одно и то же. Тот же самый метод «Отправить» из примера выше может быть реализован по-разному для видео и картинки. Но вызывается он одинаково для всех видов контента и выполняет одну и ту же задачу. Вот как это работает.

**Сначала программист создает общий класс.** Например, «контент». В нем он описывает вещи, общие для всего контента: свойства и методы. Свойства — это признаки, то, что есть у контента: количество лайков, возможность комментирования и так далее. А методы — это действия, то есть команды: контент можно лайкнуть, открыть на отдельной вкладке, репостнуть или отправить в личное сообщение.

**У общего класса — абстрактные, общие методы.** Контент можно отправить, но как — пока непонятно. Зато уже можно описать, как будет выглядеть эта команда: как она называется, что в нее нужно передать, какое сообщение выдать после этого. Это своего рода каркас будущего конкретного действия.

**Затем разработчик создает производные классы.** Это наследники общего класса: они более конкретные, у них могут быть дополнительные свойства и методы. Например, видео можно поставить на паузу, а картинку — нет. А еще у них сохраняются абстрактные свойства и методы родителя: их переопределяют, чтобы они тоже работали конкретнее.

**У производных классов — свои реализации общих методов.** Например, в классе «контент» есть метод «отправить». Он же есть и в производных классах. В классе «картинка» может быть свой код для отправки, а в классе «видео» — свой. Они могут быть похожи или различаться. Но название у них окажется одинаковым, и делать они будут одно и то же.

**Можно создавать объекты производных классов и пользоваться их методами.** Абстрактные классы существуют как бы в вакууме: нельзя создать объект, который будет принадлежать такому классу. Среди реальных объектов не может быть «просто контента», который не является ни текстом, ни картинкой, ни видео, ни еще чем-то. Соответственно, абстрактные методы никто не будет вызывать. А вот переопределенные методы из производных классов — вполне реальные, ими можно пользоваться в разных ситуациях.

## Формы полиморфизма

Существуют разные виды полиморфизма. Вообще-то классификация довольно широкая и начинающему легко в ней запутаться, поэтому мы решили ограничиться только основными формами.

**Полиморфизм подтипов.** Это полиморфность «по умолчанию»: когда в ООП говорят о полиморфизме, обычно имеют в виду его. Выше мы рассказывали именно про такой тип. Это возможность использовать одни и те же команды, или интерфейсы, для разных сущностей — подтипов.

**Параметрический полиморфизм.** Его еще называют обобщенным полиморфизмом. В нем для команды не имеет значения, какую сущность ей прислали: для всех возможных классов будет использоваться один код. Такой полиморфизм считается «истинным» и делает код универсальнее, но реализовать его сложнее.

**Полиморфизм ad hoc.** Этот вид полиморфизма еще называют специализированным. Его иногда противопоставляют параметрическому: идея ad hoc — разный код при одинаковом названии. Часто такой полиморфизм реализуют с помощью перегрузки методов: несколько раз пишут метод с одним и тем же названием, но разным кодом.

## Статический и динамический полиморфизм

На более «глубоком», близком к машине уровне полиморфизм можно разделить на две группы — статический и динамический. Разница  —в том, когда программа переходит от общего метода к одной из его вариаций.

- **Статический** — метод переопределяют при компиляции.
- **Динамический** — при выполнении программы.

Статический полиморфизм реализуют с помощью перегрузки методов, о которой мы рассказывали выше. Динамический — с помощью абстракций. Обычно в объектно-ориентированных языках есть возможность применить оба варианта.

## Преимущества полиморфизма

- Код становится аккуратнее: не приходится множить сущности и создавать десяток команд, которые делают одно и то же. Нет «лапши» — бессвязного неструктурированного кода, в котором тяжело разобраться.
- Разработчику удобнее: не нужно каждый раз думать, что делает команда «Отправить» для конкретного вида контента, можно просто написать ее и получить результат.
- Работать с разными сущностями можно одинаково: не обязательно каждый раз узнавать, о каком именно производном классе речь идет на этот раз. Ведь общее полиморфное действие есть для всего.
- Код легче расширять, использовать заново и всячески модифицировать.

## Недостатки полиморфизма

- Связь полиморфизма с наследованием порой расценивают как слабое место всей концепции. Если нужен полиформный класс, но для конкретной ситуации не подходит наследование, — реализация может усложниться.
- Не всегда полиморфизм легко реализовать на практике. Поэтому существует довольно много реализаций, которые работают плохо: с багами и необъяснимыми ошибками.
- Полиморфизм может ухудшать производительность кода, делать его более «тяжелым» и медленным. Но тут многое зависит от реализации: скажем, параметрический обычно быстрее, чем ad hoc.
- Новичкам бывает тяжело понять принцип — объяснить полиморфизм простыми словами можно только в связке с другими понятиями ООП. Так что человек на момент изучения уже должен понимать, что такое объектно-ориентированное программирование.

## Как начать изучать полиморфизм

Мы советуем начать с основ: сначала разобраться, как работает программирование в целом, потом перейти к принципам ООП и полиморфизму. На всех этапах лучше практиковаться, чтобы закреплять знания, — к тому же на реальных примерах легче понять тот или иной концепт.